<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Haven&#39;s Blog">
<meta property="og:url" content="/index.html">
<meta property="og:site_name" content="Haven&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Haven&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="/">





  <title>Haven's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Haven's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2021/04/09/CocoaPods在团队开发中的一些用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/09/CocoaPods在团队开发中的一些用法/" itemprop="url">CocoaPods在团队开发中的一些用法（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-09T10:05:59+08:00">
                2021-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="指定第三方库版本"><a href="#指定第三方库版本" class="headerlink" title="指定第三方库版本"></a>指定第三方库版本</h3><p>在第三方库名称后面引用版本号不同的用法pod下来的版本也不同，需要注意以下几点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">target &apos;MyApp&apos; do</span><br><span class="line">	pod &apos;AFNetworking&apos;,&apos;3.2.0&apos;	//统一固定版本，适合团队开发</span><br><span class="line">	#pod &apos;AFNetworking&apos;,&apos;~&gt;3.2.0&apos;	//小版本浮动，AFNetworking 会在 3.2.0 ~ 3.9.9 之间版本浮动，不包含4.0.0</span><br><span class="line">	#pod &apos;AFNetworking&apos;	//不限制版本，任何版本都可以，不过下载的版本下来肯定是最新的</span><br><span class="line">	</span><br><span class="line">	#pod &apos;AFNetworking&apos;,:head	//使用git的HEAD指向的分支</span><br><span class="line">	#pod &apos;AFNetworking&apos;,git:&apos;https://github.com/AFNetworking/AFNetworking.git&apos;	//使用master分支</span><br><span class="line">	#pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/AFNetworking/AFNetworking.git&apos;, :branch =&gt; &apos;assets&apos;	//指定branch</span><br><span class="line">	#pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :tag =&gt; &apos;3.2.0&apos;	//指定tag</span><br><span class="line">	#pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :commit =&gt; &apos;e976d63&apos;	//指定commit</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a>官网解释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. &apos;&gt; 0.1&apos;      大于0.1版本</span><br><span class="line">2. &apos;&gt;= 0.1&apos;     大于等于0.1版本</span><br><span class="line">3. &apos;&lt; 0.1&apos;      小于0.1版本</span><br><span class="line">4. &apos;&lt;= 0.1&apos;     小于等于0.1版本</span><br><span class="line">5. &apos;~&gt; 0.1.2&apos;   大于0.1.2 小于0.2，不含0.2</span><br><span class="line">6. &apos;~&gt; 0.1&apos;     0.1以上 1.0以下,不含0.1</span><br><span class="line">7. &apos;~&gt; 0&apos;       0和以上，等于没有此约束</span><br></pre></td></tr></table></figure>
<p>以AFNetworking库为例，执行 <code>pod install</code> 指令后，cocoapods会先去<code>~/.cocoapods/repo/master</code>路径下搜索AFNetworking的podspec文件(一个tag对应一个podspec文件)，podspec文件里有这个库的源代码地址，然后根据对应的tag下载源代码到cocoapods的缓存目录<code>~/Library/Caches/Cocoapods</code>。当我们在另一个项目再次安装AFNetworking的时候，cocopods会去<code>~/Library/Caches/Cocoapods</code>里查看有没有对应tag的源码，如果有的话就直接使用这个缓存的源码。</p>
<h3 id="使用本地库"><a href="#使用本地库" class="headerlink" title="使用本地库"></a>使用本地库</h3><p>团队开发中可能会遇到一些比较大的第三方库，导致团队成员执行安装时网络时间成本过高，或者有时我们需要对第三方库进行二次调整的情况，这时就需要使用到本地库概念，具体方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;MyApp&apos; do</span><br><span class="line">	pod &apos;AFNetworking&apos;, :path =&gt; &apos;~/Documents/CocoaPodsLocalLib/AFNetworking-master&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>需要注意的是本地库的目录中，必须包含podspec文件，以AFNetworking为例，解压master版本后，包里就含有<code>AFNetworking.podspec</code>文件。</p>
<p>使用本地库的方式安装的第三方库不会在<code>~/Library/Caches/Cocoapods</code>生成缓存文件。</p>
<h3 id="多target场景"><a href="#多target场景" class="headerlink" title="多target场景"></a>多target场景</h3><h5 id="指定target的依赖库"><a href="#指定target的依赖库" class="headerlink" title="指定target的依赖库"></a>指定target的依赖库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target &apos;MyApp&apos; do</span><br><span class="line"> pod &apos;SDWebImage&apos;, &apos;4.0&apos;</span><br><span class="line">    target &apos;otherTaget&apos; do</span><br><span class="line">     use_frameworks!</span><br><span class="line">     pod &apos;AFNetworking&apos;,&apos;3.2.0&apos;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h5 id="排除target"><a href="#排除target" class="headerlink" title="排除target"></a>排除target</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;MyApp&apos; :exclusive =&gt; true do</span><br><span class="line">  pod &apos;AFNetworking&apos;,&apos;3.2.0&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h5 id="指定xocdeproj"><a href="#指定xocdeproj" class="headerlink" title="指定xocdeproj"></a>指定xocdeproj</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xcodeproj &apos;testProject&apos;</span><br><span class="line">target:test do</span><br><span class="line">  pod &apos;AFNetworking&apos;,&apos;3.2.0&apos;</span><br><span class="line">  xcodeproj &apos;otherProject&apos;   </span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<h5 id="指定连接的target"><a href="#指定连接的target" class="headerlink" title="指定连接的target"></a>指定连接的target</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target link_with &apos;MyApp&apos;,&apos;otherApp&apos; do</span><br><span class="line">  pod &apos;AFNetworking&apos;,&apos;3.2.0&apos;</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><h5 id="抑制警告"><a href="#抑制警告" class="headerlink" title="抑制警告"></a>抑制警告</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;MyApp&apos; do</span><br><span class="line"> pod &apos;AFNetworking&apos;,&apos;3.2.0&apos;,:inhibit_warnings =&gt; true 	//inhibit_warnings参数能够有效的抑制CocoaPods引入的第三方代码库产生的warning</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h5 id="全局抑制警告"><a href="#全局抑制警告" class="headerlink" title="全局抑制警告"></a>全局抑制警告</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line">target &apos;MyApp&apos; do</span><br><span class="line"> pod &apos;AFNetworking&apos;,&apos;3.2.0&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h5 id="pod-install、pod-update、pod-repo-update-、-pod-install-–no-repo-update"><a href="#pod-install、pod-update、pod-repo-update-、-pod-install-–no-repo-update" class="headerlink" title="pod install、pod update、pod repo update 、 pod install –no-repo-update"></a>pod install、pod update、pod repo update 、 pod install –no-repo-update</h5><p>pod install：项目中添加或移除pod库时执行。</p>
<p>pod update：更新pod库的版本时执行。</p>
<p>pod repo update：更新整个.cocoapods下的所有库的配置文件,挨个检查对应的框架有没有新版本发布,有的话更新本地的资源配置文件。</p>
<p>pod install –no-repo-update：根据<code>podfile</code>文件或者<code>podfile.lock</code>下载并导入对应的第三方库,跳过检查资源配置文件是否需要更新的环节。</p>
<p>参考：<a href="https://blog.csdn.net/weixin_30808575/article/details/99457988" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30808575/article/details/99457988</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2021/04/05/iOS性能优化-总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/05/iOS性能优化-总结/" itemprop="url">iOS性能优化-总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-05T22:00:40+08:00">
                2021-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS网文/" itemprop="url" rel="index">
                    <span itemprop="name">iOS网文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="性能问题的解决方法总结"><a href="#性能问题的解决方法总结" class="headerlink" title="性能问题的解决方法总结"></a>性能问题的解决方法总结</h2><p>产生性能问题的原因多种多样，因此解决的办法也不尽相同，比较常用的大概有以下几种：</p>
<h4 id="1-优化业务流程"><a href="#1-优化业务流程" class="headerlink" title="1.优化业务流程"></a>1.优化业务流程</h4><p>性能优化看似高深，真正落到实处才会发现，最大的坑往往都隐藏在于业务不断累积和频繁变更之处。优化业务流程就是在满足需求的同时，提出更加高效优雅的解决方案，从根本上解决问题。从实践来看，这种方法解决问题是最彻底的，但通常也是难度最大的。</p>
<h4 id="2-合理的线程分配"><a href="#2-合理的线程分配" class="headerlink" title="2.合理的线程分配"></a>2.合理的线程分配</h4><p>由于 GCD 实在太方便了，如果不加控制，大部分需要抛到子线程操作都会被直接加到 global 队列，这样会导致两个问题，1.开的子线程越来越多，线程的开销逐渐明显，因为开启线程需要占用一定的内存空间（默认的情况下，主线程占1M,子线程占用512KB）。2.多线程情况下，网络回调的时序问题，导致数据处理错乱，而且不容易发现。为此，我们项目定了一些基本原则。</p>
<ul>
<li>UI 操作和 DataSource 的操作一定在主线程。</li>
<li>DB 操作、日志记录、网络回调都在各自的固定线程。</li>
<li>不同业务，可以通过创建队列保证数据一致性。例如，想法列表的数据加载、书籍章节下载、书架加载等。</li>
</ul>
<p>合理的线程分配，最终目的就是保证主线程尽量少的处理非UI操作，同时控制整个App的子线程数量在合理的范围内。</p>
<h4 id="3-预处理和延时加载"><a href="#3-预处理和延时加载" class="headerlink" title="3.预处理和延时加载"></a>3.预处理和延时加载</h4><p>预处理，是将初次显示需要耗费大量线程时间的操作，提前放到后台线程进行计算，再将结果数据拿来显示。</p>
<p>延时加载，是指首先加载当前必须的可视内容，在稍后一段时间内或特定事件时，再触发其他内容的加载。这种方式可以很有效的提升界面绘制速度，使体验更加流畅。（UITableView 就是最典型的例子）</p>
<p>这两种方法都是在资源比较紧张的情况下，优先处理马上要用到的数据，同时尽可能提前加载即将要用到的数据。</p>
<h4 id="4-缓存"><a href="#4-缓存" class="headerlink" title="4.缓存"></a>4.缓存</h4><p>cache可能是所有性能优化中最常用的手段，但也是我们极不推荐的手段。cache建立的成本低，见效快，但是带来维护的成本却很高。如果一定要用，也请谨慎使用，并注意以下几点：</p>
<ul>
<li>并发访问 cache 时，数据一致性问题。</li>
<li>cache 线程安全问题，防止一边修改一边遍历的 crash。</li>
<li>cache 查找时性能问题。</li>
<li>cache 的释放与重建，避免占用空间无限扩大，同时释放的粒度也要依实际需求而定。</li>
</ul>
<h4 id="5-使用正确的API"><a href="#5-使用正确的API" class="headerlink" title="5.使用正确的API"></a>5.使用正确的API</h4><p>使用正确的 API，是指在满足业务的同时，能够选择性能更优的API。</p>
<ul>
<li>选择合适的容器;</li>
<li>了解 <code>imageNamed:</code> 与 <code>imageWithContentsOfFile:</code>的差异(<code>imageNamed:</code> 适用于会重复加载的小图片，因为系统会自动缓存加载的图片，<code>imageWithContentsOfFile:</code> 仅加载图片)</li>
<li>缓存 <code>NSDateFormatter</code> 的结果。</li>
<li>寻找 <code>(NSDate *)dateFromString:(NSString )string</code> 的替换品。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//#include &lt;time.h&gt;</span><br><span class="line">time_t t;</span><br><span class="line">struct tm tm;</span><br><span class="line">strptime([iso8601String cStringUsingEncoding:NSUTF8StringEncoding], &quot;%Y-%m-%dT%H:%M:%S%z&quot;, &amp;tm);</span><br><span class="line">tm.tm_isdst = -1;</span><br><span class="line">t = mktime(&amp;tm);</span><br><span class="line">[NSDate dateWithTimeIntervalSince1970:t + [[NSTimeZone localTimeZone] secondsFromGMT]];</span><br></pre></td></tr></table></figure>
<ul>
<li>不要随意使用 <code>NSLog()</code>.</li>
<li>当试图获取磁盘中一个文件的属性信息时，使用 <code>[NSFileManager attributesOfItemAtPath:error:]</code> 会浪费大量时间读取可能根本不需要的附加属性。这时可以使用 <code>stat</code> 代替 <code>NSFileManager</code>，直接获取文件属性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;sys/stat.h&gt;</span><br><span class="line">struct stat statbuf;</span><br><span class="line">const char *cpath = [filePath fileSystemRepresentation];</span><br><span class="line">if (cpath &amp;&amp; stat(cpath, &amp;statbuf) == 0) &#123;</span><br><span class="line">    NSNumber *fileSize = [NSNumber numberWithUnsignedLongLong:statbuf.st_size];</span><br><span class="line">    NSDate *modificationDate = [NSDate dateWithTimeIntervalSince1970:statbuf.st_mtime];</span><br><span class="line">    NSDate *creationDate = [NSDate dateWithTimeIntervalSince1970:statbuf.st_ctime];</span><br><span class="line">    // etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何预防性能问题"><a href="#如何预防性能问题" class="headerlink" title="如何预防性能问题"></a>如何预防性能问题</h2><p>大部分性能问题可以通过程序员经验和能力的提升得以减少，但是因为团队成员更新、业务累积，性能问题无法避免，如何在开发测试阶段发现问题解决问题，是预防性能问题的关键。</p>
<h4 id="1-内存泄露检测工具"><a href="#1-内存泄露检测工具" class="headerlink" title="1. 内存泄露检测工具"></a>1. 内存泄露检测工具</h4><p><a href="https://github.com/Zepo/MLeaksFinder" target="_blank" rel="noopener">MLeakFinder</a> 能在开发阶段，把内存泄露问题暴露无遗，减少了很多潜在的性能问题。</p>
<h4 id="2-FPS-SQL性能监测工具条"><a href="#2-FPS-SQL性能监测工具条" class="headerlink" title="2. FPS/SQL性能监测工具条"></a>2. FPS/SQL性能监测工具条</h4><p>可参考《iOS性能优化-fps》</p>
<h4 id="3-UI-DataSource主线程检测工具。"><a href="#3-UI-DataSource主线程检测工具。" class="headerlink" title="3. UI / DataSource主线程检测工具。"></a>3. UI / DataSource主线程检测工具。</h4><p>该工具是为了保证所有的UI的操作和 DataSource 操作一定是在主线程进行，实现原理是通过 hook UIView 的 <code>-setNeedsLayout</code>，<code>-setNeedsDisplay</code>，<code>-setNeedsDisplayInRect</code> 三个方法，确保它们都是在主线程执行。子线程操作UI可能会引起什么问题，苹果说得并不清楚，实际开发中我们遇到几种神奇的问题似乎都是跟这个有关。</p>
<ul>
<li>app 突然丢动画，似乎 iOS 系统也有这个 bug。虽然没有确切的证据，但使用这个工具，改完所有的问题后，bug 也好了(不止一次是这样)。</li>
<li>UI 操作偶尔响应特别慢，从代码看没有任何耗时操作，只是简单的 push 某个 controller。</li>
<li>莫名的 crash，这当然是因为 UI 操作非线程安全引起的。</li>
</ul>
<p>更多时候，子线程操作 UI 也并不一定会发生什么问题，也正因为不知道会发生什么，所以更需要我们警惕，这个工具替我们扫除了这些隐患。虽然，苹果表示，现在部分的 UI 操作也已经是线程安全了，但毕竟大部分还不是。DataSource 的监测是因为我们业务定下的原则，保证列表 DataSource 的线程安全。</p>
<p>参考文献：<a href="https://wereadteam.github.io/2016/05/03/WeRead-Performance/" target="_blank" rel="noopener">微信读书 iOS 性能优化总结</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2021/04/05/iOS性能优化-fps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/05/iOS性能优化-fps/" itemprop="url">iOS性能优化-fps</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-05T21:34:52+08:00">
                2021-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="fps"><a href="#fps" class="headerlink" title="fps"></a>fps</h3><p>通常情况下，屏幕会保持<code>60hz/s</code>的刷新速度，每次刷新时会发出一个屏幕刷新信号，<code>CADisplayLink</code>允许我们注册一个与刷新信号同步的回调处理。可以通过屏幕刷新机制来展示<code>fps</code>值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UILabel</span> *_fpsLbe;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_link;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _lastTime;</span><br><span class="line">    <span class="keyword">float</span> _fps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="keyword">if</span> (_link) &#123;</span><br><span class="line">        [_link removeFromRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">        [_link invalidate];</span><br><span class="line">        _link = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(fpsDisplayLinkAction:)];</span><br><span class="line">    [_link addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fpsDisplayLinkAction:(<span class="built_in">CADisplayLink</span> *)link &#123;</span><br><span class="line">    <span class="keyword">if</span> (_lastTime == <span class="number">0</span>) &#123;</span><br><span class="line">        _lastTime = link.timestamp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.count++;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> delta = link.timestamp - _lastTime;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    _lastTime = link.timestamp;</span><br><span class="line">    _fps = _count / delta;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"count = %d, delta = %f,_lastTime = %f, _fps = %.0f"</span>,_count, delta, _lastTime, _fps);</span><br><span class="line">    <span class="keyword">self</span>.count = <span class="number">0</span>;</span><br><span class="line">    _fpsLbe.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"FPS:%.0f"</span>,_fps];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听count值的改变</span></span><br><span class="line"><span class="meta">#pragma mark - observer</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver &#123;</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"count"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"count new = %@, old = %@"</span>,[change valueForKey:<span class="string">@"new"</span>], [change valueForKey:<span class="string">@"old"</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span>通过打印，我们知道每次刷新时会发出一个屏幕刷新信号，则与刷新信号同步的回调方法`fpsDisplayLinkAction:`会调用，然后count加一。</span><br><span class="line"><span class="number">2.</span>每隔一秒，我们计算一次 `fps `值，用一个变量_lastTime记录上一次计算 fps 值的时间，然后将 count 的值除以时间间隔，就得到了 fps 的值，在将_lastTime重新赋值，_count置成零。</span><br><span class="line"><span class="number">3.</span>正常情况下，屏幕会保持<span class="number">60</span>hz/s的刷新速度，所以<span class="number">1</span>秒内`fpsDisplayLinkAction:`方法会调用<span class="number">60</span>次。fps 计算的值为<span class="number">0</span>，就不卡顿，流畅。</span><br><span class="line"><span class="number">4.</span>如果<span class="number">1</span>秒内`fpsDisplayLinkAction:`只回调了<span class="number">50</span>次，计算出来的fps就是 _count / delta(时间间隔) 。</span><br><span class="line">  </span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line">- (<span class="keyword">void</span>)startFpsMonitoring &#123;</span><br><span class="line">    _link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget: <span class="keyword">self</span> selector: <span class="keyword">@selector</span>(displayFps:)];</span><br><span class="line">    [_link addToRunLoop: [<span class="built_in">NSRunLoop</span> mainRunLoop] forMode: <span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)displayFps: (<span class="built_in">CADisplayLink</span> *)fpsDisplay &#123;</span><br><span class="line">    <span class="keyword">self</span>.count++;</span><br><span class="line">    <span class="built_in">CFAbsoluteTime</span> threshold = <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - _lastTime;</span><br><span class="line">    <span class="keyword">if</span> (threshold &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">        _fps = (_count / threshold);</span><br><span class="line">        _lastTime = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">        _fpsLbe.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"FPS:%.0f"</span>,_fps];</span><br><span class="line">        <span class="keyword">self</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"count = %d,_lastTime = %f, _fps = %.0f"</span>,_count, _lastTime, _fps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果和方法一差不多。</span><br></pre></td></tr></table></figure>
<p>结论</p>
<p><img src="/img/iOS性能优化-fps结论.png" alt="iOS性能优化-fps结论"></p>
<p>参考文献：iOS-卡顿监测-FPS监测(附详细代码及原理讲解) <a href="https://www.jianshu.com/p/140de3e73ad8" target="_blank" rel="noopener">https://www.jianshu.com/p/140de3e73ad8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2021/03/30/RunLoop剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/RunLoop剖析/" itemprop="url">RunLoop剖析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-30T15:26:00+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS网文/" itemprop="url" rel="index">
                    <span itemprop="name">iOS网文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是RunLoop？"><a href="#什么是RunLoop？" class="headerlink" title="什么是RunLoop？"></a>什么是RunLoop？</h2><p>通常所说的RunLoop指的是NSRunloop或者CFRunloopRef，CFRunloopRef是纯C的函数，而NSRunloop仅仅是CFRunloopRef的OC封装，并未提供额外的其他功能，RunLoop是iOS事件响应与任务处理最核心的机制，它贯穿iOS整个系统。</p>
<p>CFRunloopRef其实就是 <strong>__CFRunloop</strong> 这个结构体指针，这个对象的运行才是我们通常意义上说的运行循环，核心方法是 <strong>__CFRunloopRun()</strong></p>
<p><strong>__CFRunLoopRun</strong> 内部其实是一个 <em>do while</em> 循环，这也正是Runloop运行的本质。执行了这个函数以后就一直处于“等待-处理”的循环之中，直到循环结束。</p>
<p>Runloop运行流程</p>
<p><img src="/img/Runloop运行流程.png" alt=" RunLoop Runloop运行流程" style="zoom:70%;"></p>
<p>整个流程并不复杂（需要注意的就是 <em>黄色</em> 区域的消息处理中并不包含source0，因为它在循环开始之初就会处理），整个流程其实就是一种<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event Loop</a>的实现，其他平台均有类似的实现，只是这里叫做Runloop。但是既然RunLoop是一个消息循环，谁来管理和运行Runloop？那么它接收什么类型的消息？休眠过程是怎么样的？如何保证休眠时不占用系统资源？如何处理这些消息以及何时退出循环？</p>
<h3 id="Runloop-Mode"><a href="#Runloop-Mode" class="headerlink" title="Runloop Mode"></a>Runloop Mode</h3><p>Runloop总是运行在某种特定的CFRunLoopModeRef下（每次运行 <strong>__CFRunLoopRun()</strong> 函数时必须指定Mode）。而通过CFRunloopRef对应结构体的定义可以很容易知道每种Runloop都可以包含若干个Mode，每个Mode又包含Source/Timer/Observer。每次调用Runloop的主函数__CFRunLoopRun()时必须指定一种Mode，这个Mode称为 <strong>_currentMode</strong>，当切换Mode时必须退出当前Mode，然后重新进入Runloop以保证不同Mode的Source/Timer/Observer互不影响。</p>
<ul>
<li>Default：NSDefaultRunLoopMode，默认模式，在Run Loop没有指定Mode的时候，默认就跑在Default Mode下</li>
<li>Connection：NSConnectionReplyMode，用来监听处理网络请求NSConnection的事件</li>
<li>Modal：NSModalPanelRunLoopMode，OS X的Modal面板事件</li>
<li>Event tracking：UITrackingRunLoopMode，拖动事件</li>
<li>Common mode：NSRunLoopCommonModes，是一个模式集合，当绑定一个事件源到这个模式集合的时候就相当于绑定到了集合内的每一个模式</li>
</ul>
<p>其实这个并不是某种具体的Mode，而是一种模式组合，在iOS系统中默认包含了 NSDefaultRunLoopMode和 UITrackingRunLoopMode（注意：并不是说Runloop会运行在kCFRunLoopCommonModes这种模式下，而是相当于分别注册了 NSDefaultRunLoopMode和 UITrackingRunLoopMode。当然你也可以通过调用CFRunLoopAddCommonMode()方法将自定义Mode放到 kCFRunLoopCommonModes组合。</p>
<p>CFRunLoopRef和CFRunloopMode、CFRunLoopSourceRef/CFRunloopTimerRef/CFRunLoopObserverRef关系如下图：</p>
<p><img src="/img/CFRunloopMode三要素关系图.png" alt="CFRunloopMode三要素关系图"></p>
<p>那么CFRunLoopSourceRef、CFRunLoopTimerRef和CFRunLoopObserverRef究竟是什么？它们在Runloop运行流程中起到什么作用呢？</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p><img src="/img/Runloop结构图.png" alt="Runloop结构图"></p>
<p>Source0：负责App内部事件，由App负责管理触发，例如UITouch事件</p>
<p>Source1：对应上图的Input Source Port，Source1和Timer都属于端口事件源，不同的是所有的Timer都共用一个端口“Mode Timer Port”，而每个Source1都有不同的对应端口，Source1除了包含回调指针外包含一个mach port，和Source0需要手动触发不同，Source1可以监听系统端口和其他线程相互发送消息，它能够主动唤醒RunLoop(由操作系统内核进行管理，例如CFMessagePort消息)</p>
<p>Timer：又叫Timer Source，基于时间的触发器，上层对应NSTimer</p>
<p>Input Source：Source0、Source1、Custom Input Source 都是Input Source的一类，由其他线程手动发出</p>
<p>官方也指出可以自定义Source，因此对于CFRunLoopSourceRef来说它更像一种协议，框架已经默认定义了两种实现。</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;        /* immutable */</span><br><span class="line">    CFIndex _order;            /* immutable */</span><br><span class="line">    CFRunLoopObserverCallBack _callout;    /* immutable */</span><br><span class="line">    CFRunLoopObserverContext _context;    /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相对来说CFRunloopObserverRef理解起来并不复杂，它相当于消息循环中的一个监听器，随时通知外部当前RunLoop的运行状态（它包含一个函数指针 <em>callout</em> 将当前状态及时告诉观察者）。具体的Observer状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity)</span><br><span class="line">&#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), // 进入RunLoop </span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将开始Timer处理</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将开始Source处理</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //从休眠状态唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7), //退出RunLoop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Call-out"><a href="#Call-out" class="headerlink" title="Call out"></a>Call out</h3><p>在开发过程中几乎所有的操作都是通过Call out进行回调的(无论是Observer的状态通知还是Timer、Source的处理)，而系统在回调时通常使用如下几个函数进行回调(换句话说你的代码其实最终都是通过下面几个函数来负责调用的，即使你自己监听Observer也会先调用下面的函数然后间接通知你，所以在调用堆栈中经常看到这些函数)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</span><br><span class="line">static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</span><br></pre></td></tr></table></figure>
<p>例如在控制器的touchBegin中打入断点查看堆栈（由于UIEvent是Source0，所以可以看到一个Source0的Call out函数 <code>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</code> 调用）：</p>
<p><img src="/img/Call out示例.png" alt="Call out示例"></p>
<h3 id="RunLoop休眠"><a href="#RunLoop休眠" class="headerlink" title="RunLoop休眠"></a>RunLoop休眠</h3><p>其实对于Event Loop而言RunLoop最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。RunLoop的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件Darwin中的Mach来完成的<a href="https://opensource.apple.com/" target="_blank" rel="noopener">Darwin</a> 可以从下图最底层Kernel中找到Mach：</p>
<p><img src="/img/RunLoop休眠.png" alt="RunLoop休眠" style="zoom:67%;"></p>
<p>Mach是Darwin的核心，可以说是内核的核心，提供了进程间通信（IPC）、处理器调度等基础服务。在Mach中，进程、线程间的通信是以消息的方式来完成的，消息在两个Port之间进行传递（这也正是Source1之所以称之为Port-based Source的原因，因为它就是依靠系统发送消息到指定的Port来触发的）。消息的发送和接收使用 &lt;mach/message.h&gt; 中的 <strong>mach_msg()</strong> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line">extern mach_msg_return_t    mach_msg(</span><br><span class="line">                    mach_msg_header_t *msg,</span><br><span class="line">                    mach_msg_option_t option,</span><br><span class="line">                    mach_msg_size_t send_size,</span><br><span class="line">                    mach_msg_size_t rcv_size,</span><br><span class="line">                    mach_port_name_t rcv_name,</span><br><span class="line">                    mach_msg_timeout_t timeout,</span><br><span class="line">                    mach_port_name_t notify);</span><br></pre></td></tr></table></figure>
<p>而<strong>mach_msg()\</strong>的本质是一个调用**mach_msg_trap()<strong>,这相当于一个系统调用，会触发内核状态切换。当程序静止时，RunLoop停留在 <code>__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy)</code> ,而这个函数内部就是调用了</strong>mach_msg**让程序处于休眠状态。</p>
<h3 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h3><p>Runloop是基于pthread进行管理的，pthread是基于c的跨平台多线程操作底层API。它是mach thread的上层封装，和NSThread一一对应（而NSThread是一套面向对象的API，所以在iOS开发中我们也几乎不用直接使用pthread）</p>
<p><img src="/img/Runloop和线程的关系.png" alt="Runloop和线程的关系" style="zoom:100%;"></p>
<p>苹果开发的接口中并没有直接创建Runloop的接口，如果需要使用Runloop通常 <strong>CFRunLoopGetMain()</strong> 和 <strong>CFRunLoopGetCurrent()</strong> 两个方法来获取（通过上面的源代码也可以看到，核心逻辑在<em>CFRunLoopGet</em>当中）,通过代码并不难发现其实只有当我们使用线程的方法主动get Runloop时才会在第一次创建该线程的Runloop，同时将它保存在全局的Dictionary中（线程和Runloop二者一一对应），默认情况下线程并不会创建Runloop（主线程的Runloop比较特殊，任何线程创建之前都会保证主线程已经存在Runloop），同时在线程结束的时候也会销毁对应的Runloop</p>
<p>iOS开发过程中对于开发者而言更多的使用的是NSRunloop,它默认提供了三个常用的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)run; </span><br><span class="line"></span><br><span class="line">-(BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;</span><br><span class="line"></span><br><span class="line">-(void)runUntilDate:(NSDate *)limitDate;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>run</strong>方法对应上面<strong>CFRunloopRef</strong>中的<strong>CFRunLoopRun</strong>并不会退出，除非调用<strong>CFRunLoopStop()</strong>;通常如果想要永远不会退出RunLoop才会使用此方法，否则可以使用runUntilDate</li>
<li><strong>runMode:beforeDate:</strong> 则对应 <strong>CFRunLoopRunInMode(mode,limiteDate,true)</strong> 方法,只执行一次，执行完就退出；通常用于手动控制RunLoop（例如在while循环中）</li>
<li><strong>runUntilDate:</strong> 方法其实是 <strong>CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)</strong> 执行完并不会退出，继续下一次RunLoop直到timeout</li>
</ul>
<h2 id="RunLoop应用"><a href="#RunLoop应用" class="headerlink" title="RunLoop应用"></a>RunLoop应用</h2><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>前面一直提到Timer Source作为事件源，事实上它的上层对应就是NSTimer（其实就是CFRunloopTimerRef）这个开发者经常用到的定时器（底层基于使用mk_timer实现），甚至很多开发者接触RunLoop还是从NSTimer开始的。其实NSTimer定时器的触发正是基于RunLoop运行的，所以使用NSTimer之前必须注册到RunLoop，但是RunLoop为了节省资源并不会在非常准确的时间点调用定时器，如果一个任务执行时间较长，那么当错过一个时间点后只能等到下一个时间点执行，并不会延后执行（NSTimer提供了一个tolerance属性用于设置宽容度，如果确实想要使用NSTimer并且希望尽可能的准确，则可以设置此属性）</p>
<p>NSTimer的创建通常有两种方式，尽管都是类方法，一种是timerWithXXX，另一种scheduedTimerWithXXX</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo; </span><br><span class="line"></span><br><span class="line">+(NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo </span><br><span class="line"></span><br><span class="line">+(NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block ; </span><br><span class="line"></span><br><span class="line">+(NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo; </span><br><span class="line"></span><br><span class="line">+(NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block ; </span><br><span class="line"></span><br><span class="line">+(NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</span><br></pre></td></tr></table></figure>
<p>二者最大的区别就是后者除了创建一个定时器外会自动以<strong>NSDefaultRunLoopModeMode</strong>添加到当前线程RunLoop中，不添加到RunLoop中的NSTimer是无法正常工作的。例如下面的代码中如果timer2不加入到RunLoop中是无法正常工作的。同时注意如果滚动UIScrollView（UITableView、UICollectionview是类似的）二者是无法正常工作的，但是如果将NSDefaultRunLoopMode改为NSRunLoopCommonModes则可以正常工作，这也解释了前面介绍的Mode内容。</p>
<p>还有几点需要说明一下：</p>
<ul>
<li>NSTimer会对Target进行强引用直到任务结束或exit之后才会释放。</li>
<li>非主线程的RunLoop并不会自动运行（同时注意默认情况下非主线程的RunLoop并不会自动创建，直到第一次使用），RunLoop运行必须要在加入NSTimer或Source0、Sourc1、Observer输入后运行否则会直接退出。</li>
<li><strong>performSelector:withObject:afterDelay:</strong> 执行的本质还是通过创建一个NSTimer然后加入到当前线程RunLoop（通而过前后两次打印RunLoop信息可以看到此方法执行之后RunLoop的timer会增加1个。类似的还有performSelector:onThread:withObject:afterDelay:，只是它会在另一个线程的RunLoop中创建一个Timer），所以此方法事实上在任务执行完之前会对触发对象形成引用，任务执行完进行释放。</li>
<li>RunLoop是一个循环事实，run方法之后的代码不会立即执行，直到RunLoop退出</li>
</ul>
<p>CADisplayLink是一个执行频率（fps）和屏幕刷新相同（可以修改preferredFramesPerSecond改变刷新频率）的定时器，它也需要加入到RunLoop才能执行。与NSTimer类似，CADisplayLink同样是基于CFRunloopTimerRef实现，底层使用mk_timer（可以比较加入到RunLoop前后RunLoop中timer的变化）。和NSTimer相比它精度更高（尽管NSTimer也可以修改精度），不过和NStimer类似的是如果遇到大任务它仍然存在丢帧现象。通常情况下CADisaplayLink用于构建帧动画，看起来相对更加流畅，而NSTimer则有更广泛的用处。</p>
<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>AutoreleasePool是另一个与RunLoop相关讨论较多的话题。其实从RunLoop源代码分析，AutoreleasePool与RunLoop并没有直接的关系，之所以将两个话题放到一起讨论最主要的原因是因为在iOS应用启动后会注册两个Observer管理和维护AutoreleasePool。不妨在应用程序刚刚启动时打印 <strong>currentRunLoop</strong> 可以看到系统默认注册了很多个Observer，其中有两个Observer的callout都是 <strong>_wrapRunLoopWithAutoreleasePoolHandler</strong> ，这两个是和自动释放池相关的两个监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver 0x6080001246a0 [0x101f81df0]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = &lt;CFArray 0x60800004cae0 [0x101f81df0]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;</span><br><span class="line">&lt;CFRunLoopObserver 0x608000124420 [0x101f81df0]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = &lt;CFArray 0x60800004cae0 [0x101f81df0]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>第一个Observer会监听RunLoop的进入，它会回调<strong>objc_autoreleasePoolPush()\</strong>向当前的**AutoreleasePoolPage**增加一个哨兵对象标志创建自动释放池。这个Observer的order是-2147483647优先级最高，确保发生在所有回调操作之前。</p>
<p>第二个Observer会监听RunLoop的进入休眠和即将退出RunLoop两种状态，在即将进入休眠时会调用<strong>objc_autoreleasePoolPop()</strong> 和 <strong>objc_autoreleasePoolPush()</strong> 根据情况从最新加入的对象一直往前清理直到遇到哨兵对象。而在即将退出RunLoop时会调用<strong>objc_autoreleasePoolPop()</strong> 释放自动自动释放池内对象。这个Observer的order是2147483647，优先级最低，确保发生在所有回调操作之后。</p>
<p>主线程的其他操作通常均在这个AutoreleasePool之内（main函数中），以尽可能减少内存维护操作(当然你如果需要显式释放【例如循环】时可以自己创建AutoreleasePool否则一般不需要自己创建)。</p>
<p>其实在应用程序启动后系统还注册了其他Observer和多个Source1（例如context为CFMachPort的Source1用于接收硬件事件响应进而分发到应用程序一直到UIEvent），这里不再一一详述。</p>
<h3 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h3><p>如果打印App启动之后的主线程RunLoop可以发现另外一个callout为 <strong>___ZN2CA11Transaction17observer_callbackEP19_CFRunLoopObservermPv</strong> 的Observer，这个监听专门负责UI变化后的更新，比如修改了frame、调整了UI层级（UIView/CALayer）或者手动设置了setNeedsDisplay/setNeedsLayout之后就会将这些操作提交到全局容器。而这个Observer监听了主线程RunLoop的即将进入休眠和退出状态，一旦进入这两种状态则会遍历所有的UI更新并提交进行实际绘制更新。 通常情况下这种方式是完美的，因为除了系统的更新，还可以利用setNeedsDisplay等方法手动触发下一次RunLoop运行的更新。但是如果当前正在执行大量的逻辑运算可能UI的更新就会比较卡，因此诞生了异步绘制框架<a href="https://github.com/texturegroup/texture" target="_blank" rel="noopener">Texture</a>来解决这个问题。Texture其实是将UI排版和绘制运算尽可能放到后台，将UI的最终更新操作放到主线程（这一步也必须在主线程完成），同时提供一套类UIView或CALayer的相关属性，尽可能保证开发者的开发习惯。这个过程中Texture在主线程RunLoop中增加了一个Observer监听即将进入休眠和退出RunLoop两种状态,收到回调时遍历队列中的待处理任务一一执行。</p>
<h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><p>NSURLConnection一旦启动以后就会不断调用delegate方法接收数据，这样一个连续的的动作正是基于RunLoop来运行。</p>
<p>一旦NSURLConnection设置了delegate会立即创建一个线程<strong>com.apple.NSURLConnectionLoader</strong>，同时内部启动RunLoop并在NSDefaultMode模式下添加4个Source0。其中CFHTTPCookieStorage用于处理cookie ;CFMultiplexerSource负责各种delegate回调并在回调中唤醒delegate内部的RunLoop（通常是主线程）来执行实际操作。</p>
<p>早期版本的AFNetworking库也是基于NSURLConnection实现，为了能够在后台接收delegate回调AFNetworking内部创建了一个空的线程并启动了RunLoop，当需要使用这个后台线程执行任务时AFNetworking通过<strong>performSelector: onThread:</strong> 将这个任务放到后台线程的RunLoop中</p>
<h3 id="GCD和RunLoop的关系"><a href="#GCD和RunLoop的关系" class="headerlink" title="GCD和RunLoop的关系"></a>GCD和RunLoop的关系</h3><p>在RunLoop的源代码中可以看到用到了GCD的相关内容，但是RunLoop本身和GCD并没有直接的关系。当调用了 <strong><code>dispatch_async(dispatch_get_main_queue(), &lt;^(void)block&gt;)</code></strong> 时libDispatch会向主线程RunLoop发送消息唤醒RunLoop，RunLoop从消息中获取block，并且在 <strong><code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code></strong> 回调里执行这个block。不过这个操作仅限于主线程，其他线程dispatch操作是全部由libDispatch驱动的。</p>
<h3 id="更多RunLoop使用"><a href="#更多RunLoop使用" class="headerlink" title="更多RunLoop使用"></a>更多RunLoop使用</h3><p>前面看了很多RunLoop的系统应用和一些知名第三方库使用，那么除了这些究竟在实际开发过程中我们自己能不能适当的使用RunLoop帮我们做一些事情呢？</p>
<p>思考这个问题其实只要看RunLoopRef的包含关系就知道了，RunLoop包含多个Mode，而它的Mode又是可以自定义的，这么推断下来其实无论是Source1、Timer还是Observer开发者都可以利用，但是通常情况下不会自定义Timer，更不会自定义一个完整的Mode，利用更多的其实是Observer和Mode的切换。</p>
<p>例如很多人都熟悉的使用perfromSelector在默认模式下设置图片，防止UITableView滚动卡顿<code>[[UIImageView alloc initWithFrame:CGRectMake(0, 0, 100, 100)] performSelector:@selector(setImage:) withObject:myImage afterDelay:0.0 inModes:@NSDefaultRunLoopMode]</code></p>
<p>还有sunnyxx的<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView+FDTemplateLayoutCell</a>利用Observer在界面空闲状态下计算出UITableViewCell的高度并进行缓存。再有老谭的<a href="https://github.com/suifengqjn/PerformanceMonitor" target="_blank" rel="noopener">PerformanceMonitor</a>关于iOS实时卡顿监控，同样是利用Observer对RunLoop进行监视。</p>
<p>文章摘抄自：</p>
<p>RunLoop刨根问底：<a href="https://juejin.cn/post/6844903567455682567" target="_blank" rel="noopener">https://juejin.cn/post/6844903567455682567</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2021/03/30/iOS卡顿优化方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/iOS卡顿优化方案/" itemprop="url">iOS性能优化-卡顿优化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-30T15:19:09+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="造成卡顿的原因"><a href="#造成卡顿的原因" class="headerlink" title="造成卡顿的原因"></a>造成卡顿的原因</h3><ul>
<li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%AD%BB%E9%94%81%2F2196938%3Ffr%3Daladdin" target="_blank" rel="noopener">死锁</a></p>
</li>
<li><p>抢锁</p>
</li>
<li><p>大量的Ui绘制,复杂的UI，图文混排</p>
</li>
<li><p>主线程大量IO、大量计算</p>
</li>
</ul>
<h3 id="RunLoop-运行时"><a href="#RunLoop-运行时" class="headerlink" title="RunLoop 运行时"></a>RunLoop 运行时</h3><p>从 RunLoop 运行逻辑中，不难发现 NSRunLoop 调用方法主要在于两个状态区间：</p>
<ul>
<li><code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopBeforeWaiting</code> 之间</li>
<li><code>kCFRunLoopAfterWaiting</code> 之后</li>
</ul>
<p><strong>如果这两个时间内耗时太久而无法进入下一步，可以线程受阻。如果这个线程时主线程，表现出来就是出现了卡顿。</strong></p>
<p>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> runLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerObserver</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>,(__bridge <span class="keyword">void</span>*)<span class="keyword">self</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            <span class="literal">YES</span>,</span><br><span class="line">                                                            <span class="number">0</span>,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中UI主要集中在<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0)</code>;<br>和<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1)</code>;之前。<br>获取<code>kCFRunLoopBeforeSources</code>到<code>kCFRunLoopBeforeWaiting</code>再到<code>kCFRunLoopAfterWaiting</code>的状态就可以知道是否有卡顿的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现思路：只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手。</span><br></pre></td></tr></table></figure>
<ul>
<li>监听<code>runloop</code>状态变化</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就是runloop有一个状态改变 就记录一下</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> runLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    BGPerformanceMonitor *monitor = (__bridge BGPerformanceMonitor*)info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录状态值</span></span><br><span class="line">    monitor-&gt;activity = activity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    dispatch_semaphore_t semaphore = monitor-&gt;semaphore;</span><br><span class="line">    <span class="keyword">long</span> st = dispatch_semaphore_signal(semaphore);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_semaphore_signal:st=%ld,time:%@"</span>,st,[BGPerformanceMonitor getCurTime]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="comment">//    typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span></span><br><span class="line"><span class="comment">//        kCFRunLoopEntry = (1UL &lt;&lt; 0),    // 进入RunLoop循环(这里其实还没进入)</span></span><br><span class="line"><span class="comment">//        kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),  // RunLoop 要处理timer了</span></span><br><span class="line"><span class="comment">//        kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // RunLoop 要处理source了</span></span><br><span class="line"><span class="comment">//        kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // RunLoop要休眠了</span></span><br><span class="line"><span class="comment">//        kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),   // RunLoop醒了</span></span><br><span class="line"><span class="comment">//        kCFRunLoopExit = (1UL &lt;&lt; 7),           // RunLoop退出（和kCFRunLoopEntry对应）</span></span><br><span class="line"><span class="comment">//        kCFRunLoopAllActivities = 0x0FFFFFFFU</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (activity == kCFRunLoopEntry) &#123;  <span class="comment">// 即将进入RunLoop</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runLoopObserverCallBack - %@"</span>,<span class="string">@"kCFRunLoopEntry"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity == kCFRunLoopBeforeTimers) &#123;    <span class="comment">// 即将处理Timer</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runLoopObserverCallBack - %@"</span>,<span class="string">@"kCFRunLoopBeforeTimers"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity == kCFRunLoopBeforeSources) &#123;   <span class="comment">// 即将处理Source</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runLoopObserverCallBack - %@"</span>,<span class="string">@"kCFRunLoopBeforeSources"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity == kCFRunLoopBeforeWaiting) &#123;   <span class="comment">//即将进入休眠</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runLoopObserverCallBack - %@"</span>,<span class="string">@"kCFRunLoopBeforeWaiting"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity == kCFRunLoopAfterWaiting) &#123;    <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runLoopObserverCallBack - %@"</span>,<span class="string">@"kCFRunLoopAfterWaiting"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity == kCFRunLoopExit) &#123;    <span class="comment">// 即将退出RunLoop</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runLoopObserverCallBack - %@"</span>,<span class="string">@"kCFRunLoopExit"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity == kCFRunLoopAllActivities) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runLoopObserverCallBack - %@"</span>,<span class="string">@"kCFRunLoopAllActivities"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>开启 <code>runloop</code> 监听</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line">- (<span class="keyword">void</span>)startMonitor &#123;</span><br><span class="line">    <span class="keyword">if</span> (observer) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_semaphore_create:%@"</span>,[BGPerformanceMonitor getCurTime]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册RunLoop状态观察</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>,(__bridge <span class="keyword">void</span>*)<span class="keyword">self</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">//创建Run loop observer对象</span></span><br><span class="line">    <span class="comment">//第一个参数用于分配observer对象的内存</span></span><br><span class="line">    <span class="comment">//第二个参数用以设置observer所要关注的事件，详见回调函数myRunLoopObserver中注释</span></span><br><span class="line">    <span class="comment">//第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行</span></span><br><span class="line">    <span class="comment">//第四个参数用于设置该observer的优先级</span></span><br><span class="line">    <span class="comment">//第五个参数用于设置该observer的回调函数</span></span><br><span class="line">    <span class="comment">//第六个参数用于设置该observer的运行环境</span></span><br><span class="line">    observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                       kCFRunLoopAllActivities,</span><br><span class="line">                                       <span class="literal">YES</span>,</span><br><span class="line">                                       <span class="number">0</span>,</span><br><span class="line">                                       &amp;runLoopObserverCallBack,</span><br><span class="line">                                       &amp;context);</span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在子线程监控时长</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;   <span class="comment">// 有信号的话 就查询当前runloop的状态</span></span><br><span class="line">            <span class="comment">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span></span><br><span class="line">            <span class="comment">// 因为下面 runloop 状态改变回调方法runLoopObserverCallBack中会将信号量递增 1,所以每次 runloop 状态改变后,下面的语句都会执行一次</span></span><br><span class="line">            <span class="comment">// dispatch_semaphore_wait:Returns zero on success, or non-zero if the timeout occurred.</span></span><br><span class="line">            <span class="keyword">long</span> st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">50</span>*<span class="built_in">NSEC_PER_MSEC</span>));</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"dispatch_semaphore_wait:st=%ld,time:%@"</span>,st,[<span class="keyword">self</span> getCurTime]);</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">0</span>) &#123;  <span class="comment">// 信号量超时了 - 即 runloop 的状态长时间没有发生变更,长期处于某一个状态下</span></span><br><span class="line">                <span class="keyword">if</span> (!observer) &#123;</span><br><span class="line">                    timeoutCount = <span class="number">0</span>;</span><br><span class="line">                    semaphore = <span class="number">0</span>;</span><br><span class="line">                    activity = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"st = %ld,activity = %lu,timeoutCount = %d,time:%@"</span>,st,activity,timeoutCount,[<span class="keyword">self</span> getCurTime]);</span><br><span class="line">                <span class="comment">// kCFRunLoopBeforeSources - 即将处理source kCFRunLoopAfterWaiting - 刚从休眠中唤醒</span></span><br><span class="line">                <span class="comment">// 获取kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting的状态就可以知道是否有卡顿的情况。</span></span><br><span class="line">                <span class="comment">// kCFRunLoopBeforeSources:停留在这个状态,表示在做很多事情</span></span><br><span class="line">                <span class="keyword">if</span> (activity == kCFRunLoopBeforeSources || activity == kCFRunLoopAfterWaiting) &#123;    <span class="comment">// 发生卡顿,记录卡顿次数</span></span><br><span class="line">                    <span class="keyword">if</span> (++timeoutCount &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;   <span class="comment">// 不足 5 次,直接 continue 当次循环,不将timeoutCount置为0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 收集Crash信息也可用于实时获取各线程的调用堆栈</span></span><br><span class="line">                    PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line">                    </span><br><span class="line">                    PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">NSData</span> *data = [crashReporter generateLiveReport];</span><br><span class="line">                    PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:<span class="literal">NULL</span>];</span><br><span class="line">                    <span class="built_in">NSString</span> *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"---------卡顿信息\n%@\n--------------"</span>,report);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"dispatch_semaphore_wait timeoutCount = 0，time:%@"</span>,[<span class="keyword">self</span> getCurTime]);</span><br><span class="line">            timeoutCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="记录卡顿的函数调用"><a href="#记录卡顿的函数调用" class="headerlink" title="记录卡顿的函数调用"></a>记录卡顿的函数调用</h5><p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</span><br><span class="line">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line"><span class="built_in">NSData</span> *data = [crashReporter generateLiveReport];</span><br><span class="line">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">NSString</span> *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</span><br><span class="line">                                                          withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"------------\n%@\n------------"</span>, report);</span><br></pre></td></tr></table></figure>
<p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!</p>
<h5 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h5><p>写一个tableView视图，上下拖动，并人为设置卡顿(休眠)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123;</span><br><span class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"cell"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *text = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (indexPath.row % <span class="number">10</span> == <span class="number">0</span>) &#123;  <span class="comment">// 每10行休眠0.2S</span></span><br><span class="line">        usleep(<span class="number">500</span> * <span class="number">1000</span>); <span class="comment">// 1 * 1000 * 1000 == 1秒</span></span><br><span class="line">        text = <span class="string">@"我在做复杂的事情，需要一些时间"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"cell - %ld"</span>,indexPath.row];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cell.textLabel.text = text;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如何获取卡顿的堆栈信息</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收集Crash信息也可用于实时获取各线程的调用堆栈</span></span><br><span class="line">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line"></span><br><span class="line">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *data = [crashReporter generateLiveReport];</span><br><span class="line">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">NSString</span> *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"---------卡顿信息\n%@\n--------------"</span>,report);</span><br></pre></td></tr></table></figure>
<p>借助了一个第三方库<code>CrashReport</code>，通过该库，可以获取当前堆栈信息</p>
<p><img src="/img/CrashReport图解说明.jpeg" alt=" CrashReport图解说明" style="zoom:50%;"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/11/02/RxSwift笔记汇总-观察者（Observer）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/02/RxSwift笔记汇总-观察者（Observer）/" itemprop="url">RxSwift笔记汇总-观察者（Observer）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-02T16:34:28+08:00">
                2020-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、观察者（Observer）介绍"><a href="#一、观察者（Observer）介绍" class="headerlink" title="一、观察者（Observer）介绍"></a>一、观察者（Observer）介绍</h2><p>观察者（Observer）的作用就是监听事件，然后对这个事件做出响应。或者说任何响应事件的行为都是观察者。比如：</p>
<ul>
<li>当我们点击按钮，弹出一个提示框。那么这个“弹出一个提示框”就是观察者 Observer<void></void></li>
<li>当我们请求一个远程的 json 数据后，将其打印出来。那么这个“打印 json 数据”就是观察者 Observer<json></json></li>
</ul>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018011914534983507.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h2 id="二、直接在-subscribe、bind-方法中创建观察者"><a href="#二、直接在-subscribe、bind-方法中创建观察者" class="headerlink" title="二、直接在 subscribe、bind 方法中创建观察者"></a>二、直接在 subscribe、bind 方法中创建观察者</h2><h3 id="1，在-subscribe-方法中创建"><a href="#1，在-subscribe-方法中创建" class="headerlink" title="1，在 subscribe 方法中创建"></a>1，在 subscribe 方法中创建</h3><p>（1）创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述当事件发生时，需要如何做出响应。</p>
<p>（2）比如下面的样例，观察者就是由后面的 onNext，onError，onCompleted 这些闭包构建出来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">          </span><br><span class="line">observable.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018011920465214855.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h3 id="2，在-bind-方法中创建"><a href="#2，在-bind-方法中创建" class="headerlink" title="2，在 bind 方法中创建"></a>2，在 bind 方法中创建</h3><p>（1）下面代码我们创建一个定时生成索引数的 Observable 序列，并将索引数不断显示在 label 标签上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line"></span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind &#123; [weak self](text) in</span><br><span class="line">                //收到发出的索引数后显示到label上</span><br><span class="line">                self?.label.text = text</span><br><span class="line">            &#125;</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h2 id="三、使用-AnyObserver-创建观察者"><a href="#三、使用-AnyObserver-创建观察者" class="headerlink" title="三、使用 AnyObserver 创建观察者"></a>三、使用 AnyObserver 创建观察者</h2><p>AnyObserver 可以用来描叙任意一种观察者。</p>
<h3 id="1，配合-subscribe-方法使用"><a href="#1，配合-subscribe-方法使用" class="headerlink" title="1，配合 subscribe 方法使用"></a>1，配合 subscribe 方法使用</h3><p>比如上面第一个样例我们可以改成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//观察者</span><br><span class="line">let observer: AnyObserver&lt;String&gt; = AnyObserver &#123; (event) in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(data)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>
<h3 id="2，配合-bindTo-方法使用"><a href="#2，配合-bindTo-方法使用" class="headerlink" title="2，配合 bindTo 方法使用"></a>2，配合 bindTo 方法使用</h3><p> 也可配合 Observable 的数据绑定方法（bindTo）使用。比如上面的第二个样例我可以改成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //观察者</span><br><span class="line">        let observer: AnyObserver&lt;String&gt; = AnyObserver &#123; [weak self] (event) in</span><br><span class="line">            switch event &#123;</span><br><span class="line">            case .next(let text):</span><br><span class="line">                //收到发出的索引数后显示到label上</span><br><span class="line">                self?.label.text = text</span><br><span class="line">            default:</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind(to: observer)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h2 id="四、使用-Binder-创建观察者"><a href="#四、使用-Binder-创建观察者" class="headerlink" title="四、使用 Binder 创建观察者"></a>四、使用 Binder 创建观察者</h2><h3 id="1，基本介绍"><a href="#1，基本介绍" class="headerlink" title="1，基本介绍"></a>1，基本介绍</h3><p>（1）相较于 AnyObserver 的大而全，Binder 更专注于特定的场景。Binder 主要有以下两个特征：</p>
<ul>
<li>不会处理错误事件</li>
<li>确保绑定都是在给定 Scheduler 上执行（默认 MainScheduler）</li>
</ul>
<p>（2）一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息。</p>
<h3 id="2，使用样例"><a href="#2，使用样例" class="headerlink" title="2，使用样例"></a>2，使用样例</h3><p>（1）在上面序列数显示样例中，label 标签的文字显示就是一个典型的 UI 观察者。它在响应事件时，只会处理 next 事件，而且更新 UI 的操作需要在主线程上执行。那么这种情况下更好的方案就是使用 Binder。</p>
<p>（2）上面的样例我们改用 Binder 会简单许多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">                 </span><br><span class="line">        //观察者</span><br><span class="line">        let observer: Binder&lt;String&gt; = Binder(label) &#123; (view, text) in</span><br><span class="line">            //收到发出的索引数后显示到label上</span><br><span class="line">            view.text = text</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind(to: observer)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h3 id="附：Binder-在-RxCocoa-中的应用"><a href="#附：Binder-在-RxCocoa-中的应用" class="headerlink" title="附：Binder 在 RxCocoa 中的应用"></a>附：Binder 在 RxCocoa 中的应用</h3><p>（1）其实 RxCocoa 在对许多 UI 控件进行扩展时，就利用 Binder 将控件属性变成观查者，比如 UIControl+Rx.swift 中的 isEnabled 属性便是一个 observer ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import RxSwift</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">extension Reactive where Base: UIControl &#123;</span><br><span class="line">     </span><br><span class="line">    /// Bindable sink for `enabled` property.</span><br><span class="line">    public var isEnabled: Binder&lt;Bool&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; control, value in</span><br><span class="line">            control.isEnabled = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）因此我们可以将序列直接绑定到它上面。比如下面样例，button 会在可用、不可用这两种状态间交替变换（每隔一秒）。</p>
<p>​    <a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201804/2018042818134057189.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a>     <a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201804/201804281813472160.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">observable</span><br><span class="line">    .map &#123; $0 % 2 == 0 &#125;</span><br><span class="line">    .bind(to: button.rx.isEnabled)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h2 id="五、自定义可绑定属性"><a href="#五、自定义可绑定属性" class="headerlink" title="五、自定义可绑定属性"></a>五、自定义可绑定属性</h2><p>有时我们想让 UI 控件创建出来后默认就有一些观察者，而不必每次都为它们单独去创建观察者。比如我们想要让所有的 UIlabel 都有个 fontSize 可绑定属性，它会根据事件值自动改变标签的字体大小。</p>
<h3 id="方式一：通过对-UI-类进行扩展"><a href="#方式一：通过对-UI-类进行扩展" class="headerlink" title="方式一：通过对 UI 类进行扩展"></a>方式一：通过对 UI 类进行扩展</h3><p>（1）这里我们通过对 UILabel 进行扩展，增加了一个 fontSize 可绑定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔0.5秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; CGFloat($0) &#125;</span><br><span class="line">            .bind(to: label.fontSize) //根据索引数不断变放大字体</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(self) &#123; label, fontSize in</span><br><span class="line">            label.font = UIFont.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1946.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012010510081287.png" alt="原文:Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性）"></a><a href="https://www.hangge.com/blog/cache/detail_1946.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012010510610894.png" alt="原文:Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性）"></a></p>
<h3 id="方式二：通过对-Reactive-类进行扩展"><a href="#方式二：通过对-Reactive-类进行扩展" class="headerlink" title="方式二：通过对 Reactive 类进行扩展"></a>方式二：通过对 Reactive 类进行扩展</h3><p>既然使用了 RxSwift，那么更规范的写法应该是对 Reactive 进行扩展。这里同样是给 UILabel 增加了一个 fontSize 可绑定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔0.5秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; CGFloat($0) &#125;</span><br><span class="line">            .bind(to: label.rx.fontSize) //根据索引数不断变放大字体</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Reactive where Base: UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; label, fontSize in</span><br><span class="line">            label.font = UIFont.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、RxSwift-自带的可绑定属性（UI-观察者）"><a href="#六、RxSwift-自带的可绑定属性（UI-观察者）" class="headerlink" title="六、RxSwift 自带的可绑定属性（UI 观察者）"></a>六、RxSwift 自带的可绑定属性（UI 观察者）</h2><p>（1）其实 RxSwift 已经为我们提供许多常用的可绑定属性。比如 UILabel 就有 text 和 attributedText 这两个可绑定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import RxSwift</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">extension Reactive where Base: UILabel &#123;</span><br><span class="line">     </span><br><span class="line">    /// Bindable sink for `text` property.</span><br><span class="line">    public var text: Binder&lt;String?&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; label, text in</span><br><span class="line">            label.text = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// Bindable sink for `attributedText` property.</span><br><span class="line">    public var attributedText: Binder&lt;NSAttributedString?&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; label, text in</span><br><span class="line">            label.attributedText = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ 2）那么上文那个定时显示索引数的样例，我们其实不需要自定义 UI 观察者，直接使用 RxSwift 提供的绑定属性即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind(to: label.rx.text) //收到发出的索引数后显示到label上</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1946.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性）"></a></p>
<p>原文出自：</p>
<p><a href="http://www.hangge.com" target="_blank" rel="noopener">www.hangge.com</a></p>
<p>  转载请保留原文链接：</p>
<p><a href="https://www.hangge.com/blog/cache/detail_1946.html" target="_blank" rel="noopener">https://www.hangge.com/blog/cache/detail_1946.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/11/02/RxSwift笔记汇总-Observable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/02/RxSwift笔记汇总-Observable/" itemprop="url">RxSwift笔记汇总-Observable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-02T10:06:54+08:00">
                2020-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>RxSwift 是一个组合异步和事件驱动编程的库，通过使用可观察序列和功能样式运算符来，从而允许通过调度程序进行参数化执行。</p>
<p>RxSwift 在本质上简化了开发异步程序，允许代码对新数据作出反应，并以顺序和孤立的方式处理它。</p>
<p>Rx 代码的三个组成部分是 observables, operators 和 schedulers。</p>
<p>Observable 类提供了 Rx 代码的基础：异步产生一系列事件的能力，它可以“携带”数据的不可变快照。简单来说，它允许类在一段时间内订阅其他类发出的值。</p>
<p>ObservableType 协议 (Observable 需要符合的) 非常简单。可观测的可能发出 (并且观察员能接受) 仅三类型事件:</p>
<ul>
<li>next 下一个事件: “携带” 最新 (或 “下一个 “) 数据值的事件。这是观察者 “接收” 值的方式。</li>
<li>completed 已完成的事件: 此事件以成功终止事件序列。这意味着可观察的完成其生命周期成功, 不会发出任何其他事件。</li>
<li>error 错误事件: 可观察的终止带有错误, 不会发出其他事件。</li>
</ul>
<h2 id="创建-Observable-序列"><a href="#创建-Observable-序列" class="headerlink" title="创建 Observable 序列"></a>创建 Observable 序列</h2><p>我们可以通过如下几种方法来创建一个 <code>Observable</code>序列</p>
<ul>
<li><p>just()方法：该方法通过传入一个默认值来初始化。</p>
<p><code>let observable = Observable&lt;Int&gt;.just(5)</code></p>
</li>
<li><p>of() 方法：该方法可以接受可变数量的参数（必需要是同类型的）。</p>
<p><code>let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code></p>
</li>
<li><p>from()方法：该方法需要一个数组参数。</p>
<p><code>let observable = Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</code> </p>
</li>
<li><p>empty()方法：该方法创建一个空内容的 <code>Observable</code> 序列。 </p>
<p><code>let observable = Observable&lt;Int&gt;.empty()</code></p>
</li>
<li><p>never()方法：该方法创建一个永远不会发出 <code>Event</code>（也不会终止）的 <code>Observable</code> 序列。 </p>
<p><code>let observable = Observable&lt;Int&gt;.never()</code></p>
</li>
<li><p>error()方法：该方法创建一个不做任何操作，而是直接发送一个错误的 <code>Observable</code> 序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum MyError: Error &#123;    case A    case B&#125;         </span><br><span class="line">let observable = Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure>
</li>
<li><p>range()方法：该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的<code>Observable</code>序列。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用range()</span><br><span class="line">let observable = Observable.range(start: 1, count: 5) </span><br><span class="line">//使用of()</span><br><span class="line">let observable = Observable.of(1, 2, 3 ,4 ,5)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>repeatElement()方法：该方法创建一个可以无限发出给定元素的 <code>Event</code>的 <code>Observable</code> 序列（永不终止）。<code>let observable = Observable.repeatElement(1)</code></p>
</li>
<li><p>generate()方法：该方法创建一个只有当提供的所有的判断条件都为 <code>true</code> 的时候，才会给出动作的 <code>Observable</code> 序列。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用generate()方法</span><br><span class="line">let observable = Observable.generate(</span><br><span class="line">    initialState: 0,</span><br><span class="line">    condition: &#123; $0 &lt;= 10 &#125;,</span><br><span class="line">    iterate: &#123; $0 + 2 &#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">//使用of()方法</span><br><span class="line">let observable = Observable.of(0 , 2 ,4 ,6 ,8 ,10)</span><br></pre></td></tr></table></figure>
<ul>
<li>create()方法：该方法接受一个 <code>block</code> 形式的参数，任务是对每一个过来的订阅进行处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这个block有一个回调参数observer就是订阅这个Observable对象的订阅者</span><br><span class="line">//当一个订阅者订阅这个Observable对象的时候，就会将订阅者作为参数传入这个block来执行一些内容</span><br><span class="line">let observable = Observable&lt;String&gt;.create&#123;observer in</span><br><span class="line">    //对订阅者发出了.next事件，且携带了一个数据&quot;hangge.com&quot;</span><br><span class="line">    observer.onNext(&quot;hangge.com&quot;)</span><br><span class="line">    //对订阅者发出了.completed事件</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    //因为一个订阅行为会有一个Disposable类型的返回值，所以在结尾一定要returen一个Disposable</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//订阅测试</span><br><span class="line">observable.subscribe &#123;</span><br><span class="line">    print($0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>deferred()方法：该个方法相当于是创建一个 <code>Observable</code> 工厂，通过传入一个 <code>block</code> 来执行延迟 <code>Observable</code>序列创建的行为，而这个 <code>block</code> 里就是真正的实例化序列对象的地方。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//用于标记是奇数、还是偶数</span><br><span class="line">var isOdd = true</span><br><span class="line"> </span><br><span class="line">//使用deferred()方法延迟Observable序列的初始化，通过传入的block来实现Observable序列的初始化并且返回。</span><br><span class="line">let factory : Observable&lt;Int&gt; = Observable.deferred &#123;</span><br><span class="line">     </span><br><span class="line">    //让每次执行这个block时候都会让奇、偶数进行交替</span><br><span class="line">    isOdd = !isOdd</span><br><span class="line">     </span><br><span class="line">    //根据isOdd参数，决定创建并返回的是奇数Observable、还是偶数Observable</span><br><span class="line">    if isOdd &#123;</span><br><span class="line">        return Observable.of(1, 3, 5 ,7)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return Observable.of(2, 4, 6, 8)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//第1次订阅测试</span><br><span class="line">factory.subscribe &#123; event in</span><br><span class="line">    print(&quot;\(isOdd)&quot;, event)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//第2次订阅测试</span><br><span class="line">factory.subscribe &#123; event in</span><br><span class="line">    print(&quot;\(isOdd)&quot;, event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>interval()方法：这个方法创建的 <code>Observable</code> 序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>timer()方法：</p>
<p>这个方法有两种用法，一种是创建的 <code>Observable</code>序列在经过设定的一段时间后，产生唯一的一个元素。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//5秒种后发出唯一的一个元素0</span><br><span class="line">let observable = Observable&lt;Int&gt;.timer(5, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另一种是创建的 Observable 序列在经过设定的一段时间后，每隔一段时间产生一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//延时5秒种后，每隔1秒钟发出一个元素</span><br><span class="line">let observable = Observable&lt;Int&gt;.timer(5, period: 1, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="订阅-Observable"><a href="#订阅-Observable" class="headerlink" title="订阅 Observable"></a>订阅 Observable</h2><p>第一种用法：使用 <code>subscribe()</code> 订阅了一个<code>Observable</code> 对象，该方法的 <code>block</code> 的回调参数就是被发出的 <code>event</code> 事件，我们将其直接打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">         </span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">    print(event.element)	//获取到这个事件里的数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种用法：<code>RxSwift</code> 还提供了另一个 <code>subscribe</code>方法，它可以把 <code>event</code> 进行分类，其中<code>onNext</code>、<code>onError</code>、<code>onCompleted</code> 和 <code>onDisposed</code> 这四个回调 <code>block</code> 参数都是有默认值的，即它们都是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">         </span><br><span class="line">observable.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;, onDisposed: &#123;</span><br><span class="line">    print(&quot;disposed&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="监听事件的生命周期"><a href="#监听事件的生命周期" class="headerlink" title="监听事件的生命周期"></a>监听事件的生命周期</h2><p>我们可以使用 <code>doOn</code> 方法来监听事件的生命周期，它会在每一次事件发送前被调用。</p>
<p>同时它和 <code>subscribe</code> 一样，可以通过不同的<code>block</code> 回调处理不同类型的 <code>event</code>。比如：</p>
<ul>
<li><code>do(onNext:)</code>方法就是在<code>subscribe(onNext:)</code> 前调用</li>
<li>而 <code>do(onCompleted:)</code> 方法则会在 <code>subscribe(onCompleted:)</code> 前面调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line"> </span><br><span class="line">observable</span><br><span class="line">    .do(onNext: &#123; element in</span><br><span class="line">        print(&quot;Intercepted Next：&quot;, element)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;Intercepted Error：&quot;, error)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;Intercepted Completed&quot;)</span><br><span class="line">    &#125;, onDispose: &#123;</span><br><span class="line">        print(&quot;Intercepted Disposed&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(onNext: &#123; element in</span><br><span class="line">        print(element)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    &#125;, onDisposed: &#123;</span><br><span class="line">        print(&quot;disposed&quot;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Observable-的销毁（Dispose）"><a href="#Observable-的销毁（Dispose）" class="headerlink" title="Observable 的销毁（Dispose）"></a>Observable 的销毁（Dispose）</h2><h3 id="1，Observable-从创建到终结流程"><a href="#1，Observable-从创建到终结流程" class="headerlink" title="1，Observable 从创建到终结流程"></a>1，Observable 从创建到终结流程</h3><p> （1）一个 <code>Observable</code> 序列被创建出来后它不会马上就开始被激活从而发出 <code>Event</code>，而是要等到它被某个人订阅了才会激活它。</p>
<p>（2）而 <code>Observable</code> 序列激活之后要一直等到它发出了<code>.error</code>或者 <code>.completed</code>的 <code>event</code> 后，它才被终结。</p>
<h3 id="2，dispose-方法"><a href="#2，dispose-方法" class="headerlink" title="2，dispose() 方法"></a>2，dispose() 方法</h3><p>（1）使用该方法我们可以手动取消一个订阅行为。</p>
<p>（2）如果我们觉得这个订阅结束了不再需要了，就可以调用 <code>dispose()</code>方法把这个订阅给销毁掉，防止内存泄漏。</p>
<p>（3）当一个订阅行为被<code>dispose</code> 了，那么之后 <code>observable</code> 如果再发出 <code>event</code>，这个已经 <code>dispose</code> 的订阅就收不到消息了。下面是一个简单的使用样例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">         </span><br><span class="line">//使用subscription常量存储这个订阅方法</span><br><span class="line">let subscription = observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line">//调用这个订阅的dispose()方法</span><br><span class="line">subscription.dispose()</span><br></pre></td></tr></table></figure>
<h3 id="3，DisposeBag"><a href="#3，DisposeBag" class="headerlink" title="3，DisposeBag"></a>3，DisposeBag</h3><p>（1）除了 <code>dispose()</code>方法之外，我们更经常用到的是一个叫 <code>DisposeBag</code> 的对象来管理多个订阅行为的销毁：</p>
<ul>
<li>我们可以把一个 <code>DisposeBag</code>对象看成一个垃圾袋，把用过的订阅行为都放进去。</li>
<li>而这个<code>DisposeBag</code> 就会在自己快要<code>dealloc</code> 的时候，对它里面的所有订阅行为都调用 <code>dispose()</code>方法。</li>
</ul>
<p>（2）下面是一个简单的使用样例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">         </span><br><span class="line">//第1个Observable，及其订阅</span><br><span class="line">let observable1 = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">observable1.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">//第2个Observable，及其订阅</span><br><span class="line">let observable2 = Observable.of(1, 2, 3)</span><br><span class="line">observable2.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>摘抄至：<a href="https://www.jianshu.com/p/f61a5a988590" target="_blank" rel="noopener">RxSwift 使用详解系列</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/08/25/iOS的消息机制和消息转发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/25/iOS的消息机制和消息转发/" itemprop="url">iOS的消息机制和消息转发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-25T17:56:30+08:00">
                2020-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200826111446549.png" alt="image-20200826111446549"></p>
<h2 id="1-消息机制"><a href="#1-消息机制" class="headerlink" title="1.消息机制"></a>1.消息机制</h2><p>RunTime简称运行时。就是系统在运行的时候的一些机制，其中最主要的是消息机制。</p>
<p>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj makeText];</span><br></pre></td></tr></table></figure>
<h6 id="1-寻找类自身的方法实现"><a href="#1-寻找类自身的方法实现" class="headerlink" title="1.寻找类自身的方法实现"></a>1.寻找类自身的方法实现</h6><p>先会调用<code>objc_msgSend</code>方法，首先在Class中的缓存和方法列表中查找IMP。</p>
<p>编译器将代码[obj makeText];转化为objc_msgSend(obj, @selector (makeText));，在objc_msgSend函数中，通过obj的isa指针找到obj对应的class，在Class中先去cache中 通过SEL查找对应函数method，若 cache中未找到。再去methodList中查找。</p>
<p>可通过下列代码查找类自身的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count = 0;</span><br><span class="line">Method *methodList = class_copyMethodList([Teacher class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">	Method method = methodList[i];</span><br><span class="line">	NSLog(@&quot;__method %@&quot;, [NSString stringWithUTF8String:method_getName(method)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-寻找父类的方法实现"><a href="#2-寻找父类的方法实现" class="headerlink" title="2.寻找父类的方法实现"></a>2.寻找父类的方法实现</h6><p>若该类的methodlist中没有找到，则向父类的Class查找。如果一直查找到根类仍旧没有找到，则执行<strong>消息转发</strong>(当向someObject发送某消息，但runtime system在当前类和父类中都找不到对应方法的实现时，runtime system并不会立即报错使程序崩溃，而是依次执行下列步骤:)。</p>
<h2 id="2-消息转发"><a href="#2-消息转发" class="headerlink" title="2.消息转发"></a>2.消息转发</h2><h6 id="3-动态添加模式"><a href="#3-动态添加模式" class="headerlink" title="3. 动态添加模式"></a>3. 动态添加模式</h6><p>调用<code>resolveInstanceMethod：（实例方法）</code>或<code>resolveClassMethod:（类方法）</code>方法。允许用户在此时为该Class动态添加实现方法。如过实现了，调用并返回YES，重新开始objc_msgSend流程。如果仍没有实现，继续下面的动作。</p>
<h6 id="4-快速转发模式"><a href="#4-快速转发模式" class="headerlink" title="4.快速转发模式"></a>4.快速转发模式</h6><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，并返回非nil对象(非nil或非self)。否则返回nil，继续下面的动作。</p>
<h6 id="5-正常转发模式-消息重定向"><a href="#5-正常转发模式-消息重定向" class="headerlink" title="5.正常转发模式(消息重定向)"></a>5.正常转发模式(消息重定向)</h6><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。<br>如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。<br>如果能获取，则返回非nil并调用<code>forwardInvocation:</code>方法，将获取到的方法签名包装成Invocation传入。在<code>forwardInvocation:</code>内指定消息接收者来处理消息(如果不指定也不会报错了)。</p>
<h6 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h6><p>调用<code>doesNotRecognizeSelector</code>抛出异常。重写doesNotRecognizeSelector也可自定义异常的抛出。</p>
<h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface People : NSObject</span><br><span class="line">- (void)walk;</span><br><span class="line">- (void)eat;</span><br><span class="line">- (void)cry;</span><br><span class="line"></span><br><span class="line">- (void)doHomework;</span><br><span class="line">- (void)playOutside;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">#import &quot;People.h&quot;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation People</span><br><span class="line">- (void)walk &#123;</span><br><span class="line">    NSLog(@&quot;__walk&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    NSLog(@&quot;__无法执行 %@ 方法&quot;, methodName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;playOutside&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL sel = [anInvocation selector];</span><br><span class="line">    Student *student = [[Student alloc]  init];</span><br><span class="line">    if ([student respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:student];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;doHomework&quot;]) &#123;</span><br><span class="line">        Student *student = [[Student alloc]  init];</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;eat&quot;]) &#123;</span><br><span class="line">        class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dynamicMethodIMP(id self,SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;__eat&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>Teacher</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;People.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Teacher : People</span><br><span class="line">- (void)teacherPeople;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">#import &quot;Teacher.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Teacher</span><br><span class="line">- (void)teacherPeople &#123;</span><br><span class="line">    NSLog(@&quot;__teacherPeople&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p> Student </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;People.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Student : People</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">- (void)doHomework &#123;</span><br><span class="line">    NSLog(@&quot;__good good study, day day up&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)playOutside &#123;</span><br><span class="line">    NSLog(@&quot;__hah hah hah&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>ViewController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Teacher *teacher = [[Teacher alloc] init];</span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher walk]转化为objc_msgSend(people,@selector(teacherPeople))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续。</span><br><span class="line">    */</span><br><span class="line">    [teacher teacherPeople];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher walk]转化为objc_msgSend(teacher,@selector(walk))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类有。</span><br><span class="line">    */</span><br><span class="line">    [teacher walk];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher eat]转化为objc_msgSend(teacher,@selector(eat))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类是否动态添加了方法，这里无</span><br><span class="line">    *   查看父类是否动态添加了方法，这里有</span><br><span class="line">    */</span><br><span class="line">    [teacher eat];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher doHomework]转化为objc_msgSend(teacher,@selector(doHomework))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类、父类是否动态添加了方法，这里无</span><br><span class="line">    *   查看是否备援接收者，这里有，通过快速消息转发模式转给了Student类处理</span><br><span class="line">    */</span><br><span class="line">    [teacher doHomework];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher playOutside]转化为objc_msgSend(teacher,@selector(playOutside))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类、父类是否动态添加了方法，这里无</span><br><span class="line">    *   查看是否有无备援接收者，这里无</span><br><span class="line">    *   查看是否使用标准消息转发，这里有</span><br><span class="line">    */</span><br><span class="line">    [teacher playOutside];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher cry]转化为objc_msgSend(teacher,@selector(cry))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类、父类是否动态添加了方法，这里无</span><br><span class="line">    *   查看是否有无备援接收者，这里无</span><br><span class="line">    *   查看是否使用标准消息转发，这里无</span><br><span class="line">    *   调用doesNotRecognizeSelector，抛出异常</span><br><span class="line">    */</span><br><span class="line">    [teacher cry];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考文献：</p>
<p><a href="https://www.jianshu.com/p/23a939a0476e" target="_blank" rel="noopener">iOS 消息转发机制（依据实例展开理论）</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/08/24/TCP与UDP的一些理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/24/TCP与UDP的一些理解/" itemprop="url">TCP与UDP的一些理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-24T16:54:15+08:00">
                2020-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/底层/" itemprop="url" rel="index">
                    <span itemprop="name">底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 是<strong>面向连接</strong>的、<strong>可靠</strong>的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。</p>
<p>TCP是面向<strong>面向字节流</strong>，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p>
<p>TCP 为提供可靠性传输，实行“<strong>顺序控制</strong>”或“<strong>重发控制</strong>”机制。此外还具备“<strong>**</strong>流控制（流量控制）拥塞控制”<em>**</em>、提高网络利用率等众多功能。</p>
<p>TCP有以下特点：</p>
<ul>
<li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>
<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>
<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ <strong>主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制</strong>等机制实现）。</li>
</ul>
<h2 id="3次握手过程详解"><a href="#3次握手过程详解" class="headerlink" title="3次握手过程详解"></a>3次握手过程详解</h2><p>（1）第一次握手： Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。  （2）第二次握手： Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。  （3）第三次握手： Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 是<strong>面向报文</strong>的，所谓面向报文，是指面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p>
<p>UDP 是不<strong>具有可靠性</strong>的数据报协议，细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
<p>UDP有以下特点：</p>
<ul>
<li><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</p>
</li>
<li><p>传输途中出现丢包，UDP 也不负责重发。</p>
</li>
<li><p>当包的到达顺序出现乱序时，UDP没有纠正的功能。</p>
</li>
<li><p>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</p>
</li>
<li><p>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</p>
</li>
<li><p>UDP 常用于以下几个方面：</p>
<p>1.包总量较少的通信（DNS、SNMP等）；</p>
<p>2.视频、音频等多媒体通信（即时通信）；</p>
<p>3.限定于 LAN 等特定网络中的应用通信；</p>
<p>4.广播通信（广播、多播）。</p>
</li>
</ul>
<h2 id="UDP-和-TCP-的应用"><a href="#UDP-和-TCP-的应用" class="headerlink" title="UDP 和 TCP 的应用"></a>UDP 和 TCP 的应用</h2><p><img src="/img/UDPTCP.png" alt="image-20200824172103933"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；</p>
<p>而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p>
<p>参考文献：</p>
<p><a href="https://segmentfault.com/a/1190000021815671" target="_blank" rel="noopener">面试官：说说UDP和TCP的区别及应用场景</a></p>
<p><a href="https://www.cnblogs.com/imteck4713/p/11777310.html" target="_blank" rel="noopener">一泡尿的时间，快速读懂QUIC协议</a></p>
<p><a href="http://www.52im.net/thread-258-1-1.html" target="_blank" rel="noopener">理论经典：TCP协议的3次握手与4次挥手过程详解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/08/21/frame与bounds的一些理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/frame与bounds的一些理解/" itemprop="url">frame与bounds的一些理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-21T15:12:34+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Frame 相对比较好理解，常见的用法就是<code>aView.frame = CGRectMake(x, y, width, height);</code> 它定义了一个view相对于父视图坐标系的位置和大小，Frame 的参照点是父view的坐标系统，它会影响center属性和bounds属性的size。</p>
<p>Bounds 的默认值是(0, 0, self.frame.size.width, self.frame.size.height)，它的定义是该view在本地坐标系统中的位置和大小，它的参照点是自己坐标系统。更改bounds的size属性会以该view的center进行相对增长或收缩，修改bounds属性的origin值可以修改本地坐标系统的原点位置。</p>
<p>字面意思可以根据下图进行理解：</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821155520332.png" alt="image-20200821155520332"></p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UIView *aView = [[UIView alloc] init];</span><br><span class="line">aView.frame = CGRectMake(100, 100, 100, 100);</span><br><span class="line">aView.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:aView];</span><br><span class="line"></span><br><span class="line">UIView *bView = [[UIView alloc] init];</span><br><span class="line">bView.frame = CGRectMake(0, 0, 100, 100);</span><br><span class="line">bView.backgroundColor = [UIColor redColor];</span><br><span class="line">[aView addSubview:bView];</span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以看到aView与bView重叠在了一起</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821163929814.png" alt="image-20200821163929814"></p>
<p>给aView添加<code>aView.bounds = CGRectMake(10, 10, 100, 100);</code> 这段代码，更改aView的原点位置为10, 10，运行后得到的结果是：</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821164200582.png" alt="image-20200821164200582"></p>
<p>从图上可以看出bView向左上角偏移了。</p>
<p>原因是aView通过更改bounds的坐标点，将自身原点位置更改成了10,10，bView设置frame的x, y坐标为0时，需要从父视图aView找到0,0的位置，但bView的原点坐标已经更改成了10,10，所以bView需要向左上偏移找到0,0点的位置。</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821165537358.png" alt="image-20200821165537358"></p>
<p>如果需要改回重叠时的状态，可以更改bView的frame值，<code>bView.frame = CGRectMake(10, 10, 100, 100);</code> 。</p>
<p>如果更改aView的bounds.size的属性为   <code>aView.bounds = CGRectMake(10, 10, 100, 50);</code>  通过后台打印出aView的frame值变更成了{100, 125, 100, 50}，这是因为bounds.size属性修改时，aview会以center属性为中心进行相对收缩，上下各25，所以frame.origin.y 增加了25。</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821172801556.png" alt="image-20200821172801556"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">海文</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">海文</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
