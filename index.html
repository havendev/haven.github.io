<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Haven&#39;s Blog">
<meta property="og:url" content="/index.html">
<meta property="og:site_name" content="Haven&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Haven&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="/">





  <title>Haven's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Haven's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/11/02/RxSwift笔记汇总-观察者（Observer）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/02/RxSwift笔记汇总-观察者（Observer）/" itemprop="url">RxSwift笔记汇总-观察者（Observer）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-02T16:34:28+08:00">
                2020-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、观察者（Observer）介绍"><a href="#一、观察者（Observer）介绍" class="headerlink" title="一、观察者（Observer）介绍"></a>一、观察者（Observer）介绍</h2><p>观察者（Observer）的作用就是监听事件，然后对这个事件做出响应。或者说任何响应事件的行为都是观察者。比如：</p>
<ul>
<li>当我们点击按钮，弹出一个提示框。那么这个“弹出一个提示框”就是观察者 Observer<void></void></li>
<li>当我们请求一个远程的 json 数据后，将其打印出来。那么这个“打印 json 数据”就是观察者 Observer<json></json></li>
</ul>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018011914534983507.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h2 id="二、直接在-subscribe、bind-方法中创建观察者"><a href="#二、直接在-subscribe、bind-方法中创建观察者" class="headerlink" title="二、直接在 subscribe、bind 方法中创建观察者"></a>二、直接在 subscribe、bind 方法中创建观察者</h2><h3 id="1，在-subscribe-方法中创建"><a href="#1，在-subscribe-方法中创建" class="headerlink" title="1，在 subscribe 方法中创建"></a>1，在 subscribe 方法中创建</h3><p>（1）创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述当事件发生时，需要如何做出响应。</p>
<p>（2）比如下面的样例，观察者就是由后面的 onNext，onError，onCompleted 这些闭包构建出来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">          </span><br><span class="line">observable.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018011920465214855.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h3 id="2，在-bind-方法中创建"><a href="#2，在-bind-方法中创建" class="headerlink" title="2，在 bind 方法中创建"></a>2，在 bind 方法中创建</h3><p>（1）下面代码我们创建一个定时生成索引数的 Observable 序列，并将索引数不断显示在 label 标签上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line"></span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind &#123; [weak self](text) in</span><br><span class="line">                //收到发出的索引数后显示到label上</span><br><span class="line">                self?.label.text = text</span><br><span class="line">            &#125;</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h2 id="三、使用-AnyObserver-创建观察者"><a href="#三、使用-AnyObserver-创建观察者" class="headerlink" title="三、使用 AnyObserver 创建观察者"></a>三、使用 AnyObserver 创建观察者</h2><p>AnyObserver 可以用来描叙任意一种观察者。</p>
<h3 id="1，配合-subscribe-方法使用"><a href="#1，配合-subscribe-方法使用" class="headerlink" title="1，配合 subscribe 方法使用"></a>1，配合 subscribe 方法使用</h3><p>比如上面第一个样例我们可以改成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//观察者</span><br><span class="line">let observer: AnyObserver&lt;String&gt; = AnyObserver &#123; (event) in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(data)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>
<h3 id="2，配合-bindTo-方法使用"><a href="#2，配合-bindTo-方法使用" class="headerlink" title="2，配合 bindTo 方法使用"></a>2，配合 bindTo 方法使用</h3><p> 也可配合 Observable 的数据绑定方法（bindTo）使用。比如上面的第二个样例我可以改成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //观察者</span><br><span class="line">        let observer: AnyObserver&lt;String&gt; = AnyObserver &#123; [weak self] (event) in</span><br><span class="line">            switch event &#123;</span><br><span class="line">            case .next(let text):</span><br><span class="line">                //收到发出的索引数后显示到label上</span><br><span class="line">                self?.label.text = text</span><br><span class="line">            default:</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind(to: observer)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h2 id="四、使用-Binder-创建观察者"><a href="#四、使用-Binder-创建观察者" class="headerlink" title="四、使用 Binder 创建观察者"></a>四、使用 Binder 创建观察者</h2><h3 id="1，基本介绍"><a href="#1，基本介绍" class="headerlink" title="1，基本介绍"></a>1，基本介绍</h3><p>（1）相较于 AnyObserver 的大而全，Binder 更专注于特定的场景。Binder 主要有以下两个特征：</p>
<ul>
<li>不会处理错误事件</li>
<li>确保绑定都是在给定 Scheduler 上执行（默认 MainScheduler）</li>
</ul>
<p>（2）一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息。</p>
<h3 id="2，使用样例"><a href="#2，使用样例" class="headerlink" title="2，使用样例"></a>2，使用样例</h3><p>（1）在上面序列数显示样例中，label 标签的文字显示就是一个典型的 UI 观察者。它在响应事件时，只会处理 next 事件，而且更新 UI 的操作需要在主线程上执行。那么这种情况下更好的方案就是使用 Binder。</p>
<p>（2）上面的样例我们改用 Binder 会简单许多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">                 </span><br><span class="line">        //观察者</span><br><span class="line">        let observer: Binder&lt;String&gt; = Binder(label) &#123; (view, text) in</span><br><span class="line">            //收到发出的索引数后显示到label上</span><br><span class="line">            view.text = text</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind(to: observer)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<h3 id="附：Binder-在-RxCocoa-中的应用"><a href="#附：Binder-在-RxCocoa-中的应用" class="headerlink" title="附：Binder 在 RxCocoa 中的应用"></a>附：Binder 在 RxCocoa 中的应用</h3><p>（1）其实 RxCocoa 在对许多 UI 控件进行扩展时，就利用 Binder 将控件属性变成观查者，比如 UIControl+Rx.swift 中的 isEnabled 属性便是一个 observer ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import RxSwift</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">extension Reactive where Base: UIControl &#123;</span><br><span class="line">     </span><br><span class="line">    /// Bindable sink for `enabled` property.</span><br><span class="line">    public var isEnabled: Binder&lt;Bool&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; control, value in</span><br><span class="line">            control.isEnabled = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）因此我们可以将序列直接绑定到它上面。比如下面样例，button 会在可用、不可用这两种状态间交替变换（每隔一秒）。</p>
<p>​    <a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201804/2018042818134057189.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a>     <a href="https://www.hangge.com/blog/cache/detail_1941.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201804/201804281813472160.png" alt="原文:Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">observable</span><br><span class="line">    .map &#123; $0 % 2 == 0 &#125;</span><br><span class="line">    .bind(to: button.rx.isEnabled)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h2 id="五、自定义可绑定属性"><a href="#五、自定义可绑定属性" class="headerlink" title="五、自定义可绑定属性"></a>五、自定义可绑定属性</h2><p>有时我们想让 UI 控件创建出来后默认就有一些观察者，而不必每次都为它们单独去创建观察者。比如我们想要让所有的 UIlabel 都有个 fontSize 可绑定属性，它会根据事件值自动改变标签的字体大小。</p>
<h3 id="方式一：通过对-UI-类进行扩展"><a href="#方式一：通过对-UI-类进行扩展" class="headerlink" title="方式一：通过对 UI 类进行扩展"></a>方式一：通过对 UI 类进行扩展</h3><p>（1）这里我们通过对 UILabel 进行扩展，增加了一个 fontSize 可绑定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔0.5秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; CGFloat($0) &#125;</span><br><span class="line">            .bind(to: label.fontSize) //根据索引数不断变放大字体</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(self) &#123; label, fontSize in</span><br><span class="line">            label.font = UIFont.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1946.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012010510081287.png" alt="原文:Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性）"></a><a href="https://www.hangge.com/blog/cache/detail_1946.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012010510610894.png" alt="原文:Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性）"></a></p>
<h3 id="方式二：通过对-Reactive-类进行扩展"><a href="#方式二：通过对-Reactive-类进行扩展" class="headerlink" title="方式二：通过对 Reactive 类进行扩展"></a>方式二：通过对 Reactive 类进行扩展</h3><p>既然使用了 RxSwift，那么更规范的写法应该是对 Reactive 进行扩展。这里同样是给 UILabel 增加了一个 fontSize 可绑定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔0.5秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; CGFloat($0) &#125;</span><br><span class="line">            .bind(to: label.rx.fontSize) //根据索引数不断变放大字体</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Reactive where Base: UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; label, fontSize in</span><br><span class="line">            label.font = UIFont.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、RxSwift-自带的可绑定属性（UI-观察者）"><a href="#六、RxSwift-自带的可绑定属性（UI-观察者）" class="headerlink" title="六、RxSwift 自带的可绑定属性（UI 观察者）"></a>六、RxSwift 自带的可绑定属性（UI 观察者）</h2><p>（1）其实 RxSwift 已经为我们提供许多常用的可绑定属性。比如 UILabel 就有 text 和 attributedText 这两个可绑定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import RxSwift</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">extension Reactive where Base: UILabel &#123;</span><br><span class="line">     </span><br><span class="line">    /// Bindable sink for `text` property.</span><br><span class="line">    public var text: Binder&lt;String?&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; label, text in</span><br><span class="line">            label.text = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// Bindable sink for `attributedText` property.</span><br><span class="line">    public var attributedText: Binder&lt;NSAttributedString?&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; label, text in</span><br><span class="line">            label.attributedText = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ 2）那么上文那个定时显示索引数的样例，我们其实不需要自定义 UI 观察者，直接使用 RxSwift 提供的绑定属性即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">     </span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">         </span><br><span class="line">        //Observable序列（每隔1秒钟发出一个索引数）</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable</span><br><span class="line">            .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">            .bind(to: label.rx.text) //收到发出的索引数后显示到label上</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.hangge.com/blog/cache/detail_1946.html#" target="_blank" rel="noopener"><img src="https://www.hangge.com/blog_uploads/201801/2018012009284156168.png" alt="原文:Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性）"></a></p>
<p>原文出自：</p>
<p><a href="http://www.hangge.com" target="_blank" rel="noopener">www.hangge.com</a></p>
<p>  转载请保留原文链接：</p>
<p><a href="https://www.hangge.com/blog/cache/detail_1946.html" target="_blank" rel="noopener">https://www.hangge.com/blog/cache/detail_1946.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/11/02/RxSwift笔记汇总-Observable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/02/RxSwift笔记汇总-Observable/" itemprop="url">RxSwift笔记汇总-Observable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-02T10:06:54+08:00">
                2020-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>RxSwift 是一个组合异步和事件驱动编程的库，通过使用可观察序列和功能样式运算符来，从而允许通过调度程序进行参数化执行。</p>
<p>RxSwift 在本质上简化了开发异步程序，允许代码对新数据作出反应，并以顺序和孤立的方式处理它。</p>
<p>Rx 代码的三个组成部分是 observables, operators 和 schedulers。</p>
<p>Observable 类提供了 Rx 代码的基础：异步产生一系列事件的能力，它可以“携带”数据的不可变快照。简单来说，它允许类在一段时间内订阅其他类发出的值。</p>
<p>ObservableType 协议 (Observable 需要符合的) 非常简单。可观测的可能发出 (并且观察员能接受) 仅三类型事件:</p>
<ul>
<li>next 下一个事件: “携带” 最新 (或 “下一个 “) 数据值的事件。这是观察者 “接收” 值的方式。</li>
<li>completed 已完成的事件: 此事件以成功终止事件序列。这意味着可观察的完成其生命周期成功, 不会发出任何其他事件。</li>
<li>error 错误事件: 可观察的终止带有错误, 不会发出其他事件。</li>
</ul>
<h2 id="创建-Observable-序列"><a href="#创建-Observable-序列" class="headerlink" title="创建 Observable 序列"></a>创建 Observable 序列</h2><p>我们可以通过如下几种方法来创建一个 <code>Observable</code>序列</p>
<ul>
<li><p>just()方法：该方法通过传入一个默认值来初始化。</p>
<p><code>let observable = Observable&lt;Int&gt;.just(5)</code></p>
</li>
<li><p>of() 方法：该方法可以接受可变数量的参数（必需要是同类型的）。</p>
<p><code>let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code></p>
</li>
<li><p>from()方法：该方法需要一个数组参数。</p>
<p><code>let observable = Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</code> </p>
</li>
<li><p>empty()方法：该方法创建一个空内容的 <code>Observable</code> 序列。 </p>
<p><code>let observable = Observable&lt;Int&gt;.empty()</code></p>
</li>
<li><p>never()方法：该方法创建一个永远不会发出 <code>Event</code>（也不会终止）的 <code>Observable</code> 序列。 </p>
<p><code>let observable = Observable&lt;Int&gt;.never()</code></p>
</li>
<li><p>error()方法：该方法创建一个不做任何操作，而是直接发送一个错误的 <code>Observable</code> 序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum MyError: Error &#123;    case A    case B&#125;         </span><br><span class="line">let observable = Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure>
</li>
<li><p>range()方法：该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的<code>Observable</code>序列。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用range()</span><br><span class="line">let observable = Observable.range(start: 1, count: 5) </span><br><span class="line">//使用of()</span><br><span class="line">let observable = Observable.of(1, 2, 3 ,4 ,5)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>repeatElement()方法：该方法创建一个可以无限发出给定元素的 <code>Event</code>的 <code>Observable</code> 序列（永不终止）。<code>let observable = Observable.repeatElement(1)</code></p>
</li>
<li><p>generate()方法：该方法创建一个只有当提供的所有的判断条件都为 <code>true</code> 的时候，才会给出动作的 <code>Observable</code> 序列。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用generate()方法</span><br><span class="line">let observable = Observable.generate(</span><br><span class="line">    initialState: 0,</span><br><span class="line">    condition: &#123; $0 &lt;= 10 &#125;,</span><br><span class="line">    iterate: &#123; $0 + 2 &#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">//使用of()方法</span><br><span class="line">let observable = Observable.of(0 , 2 ,4 ,6 ,8 ,10)</span><br></pre></td></tr></table></figure>
<ul>
<li>create()方法：该方法接受一个 <code>block</code> 形式的参数，任务是对每一个过来的订阅进行处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这个block有一个回调参数observer就是订阅这个Observable对象的订阅者</span><br><span class="line">//当一个订阅者订阅这个Observable对象的时候，就会将订阅者作为参数传入这个block来执行一些内容</span><br><span class="line">let observable = Observable&lt;String&gt;.create&#123;observer in</span><br><span class="line">    //对订阅者发出了.next事件，且携带了一个数据&quot;hangge.com&quot;</span><br><span class="line">    observer.onNext(&quot;hangge.com&quot;)</span><br><span class="line">    //对订阅者发出了.completed事件</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    //因为一个订阅行为会有一个Disposable类型的返回值，所以在结尾一定要returen一个Disposable</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//订阅测试</span><br><span class="line">observable.subscribe &#123;</span><br><span class="line">    print($0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>deferred()方法：该个方法相当于是创建一个 <code>Observable</code> 工厂，通过传入一个 <code>block</code> 来执行延迟 <code>Observable</code>序列创建的行为，而这个 <code>block</code> 里就是真正的实例化序列对象的地方。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//用于标记是奇数、还是偶数</span><br><span class="line">var isOdd = true</span><br><span class="line"> </span><br><span class="line">//使用deferred()方法延迟Observable序列的初始化，通过传入的block来实现Observable序列的初始化并且返回。</span><br><span class="line">let factory : Observable&lt;Int&gt; = Observable.deferred &#123;</span><br><span class="line">     </span><br><span class="line">    //让每次执行这个block时候都会让奇、偶数进行交替</span><br><span class="line">    isOdd = !isOdd</span><br><span class="line">     </span><br><span class="line">    //根据isOdd参数，决定创建并返回的是奇数Observable、还是偶数Observable</span><br><span class="line">    if isOdd &#123;</span><br><span class="line">        return Observable.of(1, 3, 5 ,7)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return Observable.of(2, 4, 6, 8)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//第1次订阅测试</span><br><span class="line">factory.subscribe &#123; event in</span><br><span class="line">    print(&quot;\(isOdd)&quot;, event)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//第2次订阅测试</span><br><span class="line">factory.subscribe &#123; event in</span><br><span class="line">    print(&quot;\(isOdd)&quot;, event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>interval()方法：这个方法创建的 <code>Observable</code> 序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>timer()方法：</p>
<p>这个方法有两种用法，一种是创建的 <code>Observable</code>序列在经过设定的一段时间后，产生唯一的一个元素。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//5秒种后发出唯一的一个元素0</span><br><span class="line">let observable = Observable&lt;Int&gt;.timer(5, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另一种是创建的 Observable 序列在经过设定的一段时间后，每隔一段时间产生一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//延时5秒种后，每隔1秒钟发出一个元素</span><br><span class="line">let observable = Observable&lt;Int&gt;.timer(5, period: 1, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="订阅-Observable"><a href="#订阅-Observable" class="headerlink" title="订阅 Observable"></a>订阅 Observable</h2><p>第一种用法：使用 <code>subscribe()</code> 订阅了一个<code>Observable</code> 对象，该方法的 <code>block</code> 的回调参数就是被发出的 <code>event</code> 事件，我们将其直接打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">         </span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">    print(event.element)	//获取到这个事件里的数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种用法：<code>RxSwift</code> 还提供了另一个 <code>subscribe</code>方法，它可以把 <code>event</code> 进行分类，其中<code>onNext</code>、<code>onError</code>、<code>onCompleted</code> 和 <code>onDisposed</code> 这四个回调 <code>block</code> 参数都是有默认值的，即它们都是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">         </span><br><span class="line">observable.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;, onDisposed: &#123;</span><br><span class="line">    print(&quot;disposed&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="监听事件的生命周期"><a href="#监听事件的生命周期" class="headerlink" title="监听事件的生命周期"></a>监听事件的生命周期</h2><p>我们可以使用 <code>doOn</code> 方法来监听事件的生命周期，它会在每一次事件发送前被调用。</p>
<p>同时它和 <code>subscribe</code> 一样，可以通过不同的<code>block</code> 回调处理不同类型的 <code>event</code>。比如：</p>
<ul>
<li><code>do(onNext:)</code>方法就是在<code>subscribe(onNext:)</code> 前调用</li>
<li>而 <code>do(onCompleted:)</code> 方法则会在 <code>subscribe(onCompleted:)</code> 前面调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line"> </span><br><span class="line">observable</span><br><span class="line">    .do(onNext: &#123; element in</span><br><span class="line">        print(&quot;Intercepted Next：&quot;, element)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;Intercepted Error：&quot;, error)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;Intercepted Completed&quot;)</span><br><span class="line">    &#125;, onDispose: &#123;</span><br><span class="line">        print(&quot;Intercepted Disposed&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(onNext: &#123; element in</span><br><span class="line">        print(element)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    &#125;, onDisposed: &#123;</span><br><span class="line">        print(&quot;disposed&quot;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Observable-的销毁（Dispose）"><a href="#Observable-的销毁（Dispose）" class="headerlink" title="Observable 的销毁（Dispose）"></a>Observable 的销毁（Dispose）</h2><h3 id="1，Observable-从创建到终结流程"><a href="#1，Observable-从创建到终结流程" class="headerlink" title="1，Observable 从创建到终结流程"></a>1，Observable 从创建到终结流程</h3><p> （1）一个 <code>Observable</code> 序列被创建出来后它不会马上就开始被激活从而发出 <code>Event</code>，而是要等到它被某个人订阅了才会激活它。</p>
<p>（2）而 <code>Observable</code> 序列激活之后要一直等到它发出了<code>.error</code>或者 <code>.completed</code>的 <code>event</code> 后，它才被终结。</p>
<h3 id="2，dispose-方法"><a href="#2，dispose-方法" class="headerlink" title="2，dispose() 方法"></a>2，dispose() 方法</h3><p>（1）使用该方法我们可以手动取消一个订阅行为。</p>
<p>（2）如果我们觉得这个订阅结束了不再需要了，就可以调用 <code>dispose()</code>方法把这个订阅给销毁掉，防止内存泄漏。</p>
<p>（3）当一个订阅行为被<code>dispose</code> 了，那么之后 <code>observable</code> 如果再发出 <code>event</code>，这个已经 <code>dispose</code> 的订阅就收不到消息了。下面是一个简单的使用样例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">         </span><br><span class="line">//使用subscription常量存储这个订阅方法</span><br><span class="line">let subscription = observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line">//调用这个订阅的dispose()方法</span><br><span class="line">subscription.dispose()</span><br></pre></td></tr></table></figure>
<h3 id="3，DisposeBag"><a href="#3，DisposeBag" class="headerlink" title="3，DisposeBag"></a>3，DisposeBag</h3><p>（1）除了 <code>dispose()</code>方法之外，我们更经常用到的是一个叫 <code>DisposeBag</code> 的对象来管理多个订阅行为的销毁：</p>
<ul>
<li>我们可以把一个 <code>DisposeBag</code>对象看成一个垃圾袋，把用过的订阅行为都放进去。</li>
<li>而这个<code>DisposeBag</code> 就会在自己快要<code>dealloc</code> 的时候，对它里面的所有订阅行为都调用 <code>dispose()</code>方法。</li>
</ul>
<p>（2）下面是一个简单的使用样例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">         </span><br><span class="line">//第1个Observable，及其订阅</span><br><span class="line">let observable1 = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">observable1.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">//第2个Observable，及其订阅</span><br><span class="line">let observable2 = Observable.of(1, 2, 3)</span><br><span class="line">observable2.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>摘抄至：<a href="https://www.jianshu.com/p/f61a5a988590" target="_blank" rel="noopener">RxSwift 使用详解系列</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/08/25/iOS的消息机制和消息转发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/25/iOS的消息机制和消息转发/" itemprop="url">iOS的消息机制和消息转发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-25T17:56:30+08:00">
                2020-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200826111446549.png" alt="image-20200826111446549"></p>
<h2 id="1-消息机制"><a href="#1-消息机制" class="headerlink" title="1.消息机制"></a>1.消息机制</h2><p>RunTime简称运行时。就是系统在运行的时候的一些机制，其中最主要的是消息机制。</p>
<p>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj makeText];</span><br></pre></td></tr></table></figure>
<h6 id="1-寻找类自身的方法实现"><a href="#1-寻找类自身的方法实现" class="headerlink" title="1.寻找类自身的方法实现"></a>1.寻找类自身的方法实现</h6><p>先会调用<code>objc_msgSend</code>方法，首先在Class中的缓存和方法列表中查找IMP。</p>
<p>编译器将代码[obj makeText];转化为objc_msgSend(obj, @selector (makeText));，在objc_msgSend函数中，通过obj的isa指针找到obj对应的class，在Class中先去cache中 通过SEL查找对应函数method，若 cache中未找到。再去methodList中查找。</p>
<p>可通过下列代码查找类自身的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count = 0;</span><br><span class="line">Method *methodList = class_copyMethodList([Teacher class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">	Method method = methodList[i];</span><br><span class="line">	NSLog(@&quot;__method %@&quot;, [NSString stringWithUTF8String:method_getName(method)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-寻找父类的方法实现"><a href="#2-寻找父类的方法实现" class="headerlink" title="2.寻找父类的方法实现"></a>2.寻找父类的方法实现</h6><p>若该类的methodlist中没有找到，则向父类的Class查找。如果一直查找到根类仍旧没有找到，则执行<strong>消息转发</strong>(当向someObject发送某消息，但runtime system在当前类和父类中都找不到对应方法的实现时，runtime system并不会立即报错使程序崩溃，而是依次执行下列步骤:)。</p>
<h2 id="2-消息转发"><a href="#2-消息转发" class="headerlink" title="2.消息转发"></a>2.消息转发</h2><h6 id="3-动态添加模式"><a href="#3-动态添加模式" class="headerlink" title="3. 动态添加模式"></a>3. 动态添加模式</h6><p>调用<code>resolveInstanceMethod：（实例方法）</code>或<code>resolveClassMethod:（类方法）</code>方法。允许用户在此时为该Class动态添加实现方法。如过实现了，调用并返回YES，重新开始objc_msgSend流程。如果仍没有实现，继续下面的动作。</p>
<h6 id="4-快速转发模式"><a href="#4-快速转发模式" class="headerlink" title="4.快速转发模式"></a>4.快速转发模式</h6><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，并返回非nil对象(非nil或非self)。否则返回nil，继续下面的动作。</p>
<h6 id="5-正常转发模式-消息重定向"><a href="#5-正常转发模式-消息重定向" class="headerlink" title="5.正常转发模式(消息重定向)"></a>5.正常转发模式(消息重定向)</h6><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。<br>如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。<br>如果能获取，则返回非nil并调用<code>forwardInvocation:</code>方法，将获取到的方法签名包装成Invocation传入。在<code>forwardInvocation:</code>内指定消息接收者来处理消息(如果不指定也不会报错了)。</p>
<h6 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h6><p>调用<code>doesNotRecognizeSelector</code>抛出异常。重写doesNotRecognizeSelector也可自定义异常的抛出。</p>
<h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface People : NSObject</span><br><span class="line">- (void)walk;</span><br><span class="line">- (void)eat;</span><br><span class="line">- (void)cry;</span><br><span class="line"></span><br><span class="line">- (void)doHomework;</span><br><span class="line">- (void)playOutside;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">#import &quot;People.h&quot;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation People</span><br><span class="line">- (void)walk &#123;</span><br><span class="line">    NSLog(@&quot;__walk&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    NSLog(@&quot;__无法执行 %@ 方法&quot;, methodName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;playOutside&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL sel = [anInvocation selector];</span><br><span class="line">    Student *student = [[Student alloc]  init];</span><br><span class="line">    if ([student respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:student];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;doHomework&quot;]) &#123;</span><br><span class="line">        Student *student = [[Student alloc]  init];</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">    if ([methodName isEqualToString:@&quot;eat&quot;]) &#123;</span><br><span class="line">        class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dynamicMethodIMP(id self,SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;__eat&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>Teacher</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;People.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Teacher : People</span><br><span class="line">- (void)teacherPeople;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">#import &quot;Teacher.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Teacher</span><br><span class="line">- (void)teacherPeople &#123;</span><br><span class="line">    NSLog(@&quot;__teacherPeople&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p> Student </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;People.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Student : People</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">- (void)doHomework &#123;</span><br><span class="line">    NSLog(@&quot;__good good study, day day up&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)playOutside &#123;</span><br><span class="line">    NSLog(@&quot;__hah hah hah&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>ViewController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Teacher *teacher = [[Teacher alloc] init];</span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher walk]转化为objc_msgSend(people,@selector(teacherPeople))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续。</span><br><span class="line">    */</span><br><span class="line">    [teacher teacherPeople];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher walk]转化为objc_msgSend(teacher,@selector(walk))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类有。</span><br><span class="line">    */</span><br><span class="line">    [teacher walk];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher eat]转化为objc_msgSend(teacher,@selector(eat))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类是否动态添加了方法，这里无</span><br><span class="line">    *   查看父类是否动态添加了方法，这里有</span><br><span class="line">    */</span><br><span class="line">    [teacher eat];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher doHomework]转化为objc_msgSend(teacher,@selector(doHomework))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类、父类是否动态添加了方法，这里无</span><br><span class="line">    *   查看是否备援接收者，这里有，通过快速消息转发模式转给了Student类处理</span><br><span class="line">    */</span><br><span class="line">    [teacher doHomework];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher playOutside]转化为objc_msgSend(teacher,@selector(playOutside))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类、父类是否动态添加了方法，这里无</span><br><span class="line">    *   查看是否有无备援接收者，这里无</span><br><span class="line">    *   查看是否使用标准消息转发，这里有</span><br><span class="line">    */</span><br><span class="line">    [teacher playOutside];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    *   此时会将[teacher cry]转化为objc_msgSend(teacher,@selector(cry))。</span><br><span class="line">    *   查看缓存中是否有匹配的函数指针（IMP），如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看方法列表中是否有匹配的函数指针（IMP）, ，如果有则执行，否则继续，这里无。</span><br><span class="line">    *   查看父类中是否有匹配的函数指针（IMP）, 如果有则执行，否则继续，这里父类无。</span><br><span class="line">    *   查看所属类、父类是否动态添加了方法，这里无</span><br><span class="line">    *   查看是否有无备援接收者，这里无</span><br><span class="line">    *   查看是否使用标准消息转发，这里无</span><br><span class="line">    *   调用doesNotRecognizeSelector，抛出异常</span><br><span class="line">    */</span><br><span class="line">    [teacher cry];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考文献：</p>
<p><a href="https://www.jianshu.com/p/23a939a0476e" target="_blank" rel="noopener">iOS 消息转发机制（依据实例展开理论）</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2020/08/21/frame与bounds的一些理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/frame与bounds的一些理解/" itemprop="url">frame与bounds的一些理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-21T15:12:34+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Frame 相对比较好理解，常见的用法就是<code>aView.frame = CGRectMake(x, y, width, height);</code> 它定义了一个view相对于父视图坐标系的位置和大小，Frame 的参照点是父view的坐标系统，它会影响center属性和bounds属性的size。</p>
<p>Bounds 的默认值是(0, 0, self.frame.size.width, self.frame.size.height)，它的定义是该view在本地坐标系统中的位置和大小，它的参照点是自己坐标系统。更改bounds的size属性会以该view的center进行相对增长或收缩，修改bounds属性的origin值可以修改本地坐标系统的原点位置。</p>
<p>字面意思可以根据下图进行理解：</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821155520332.png" alt="image-20200821155520332"></p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UIView *aView = [[UIView alloc] init];</span><br><span class="line">aView.frame = CGRectMake(100, 100, 100, 100);</span><br><span class="line">aView.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:aView];</span><br><span class="line"></span><br><span class="line">UIView *bView = [[UIView alloc] init];</span><br><span class="line">bView.frame = CGRectMake(0, 0, 100, 100);</span><br><span class="line">bView.backgroundColor = [UIColor redColor];</span><br><span class="line">[aView addSubview:bView];</span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以看到aView与bView重叠在了一起</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821163929814.png" alt="image-20200821163929814"></p>
<p>给aView添加<code>aView.bounds = CGRectMake(10, 10, 100, 100);</code> 这段代码，更改aView的原点位置为10, 10，运行后得到的结果是：</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821164200582.png" alt="image-20200821164200582"></p>
<p>从图上可以看出bView向左上角偏移了。</p>
<p>原因是aView通过更改bounds的坐标点，将自身原点位置更改成了10,10，bView设置frame的x, y坐标为0时，需要从父视图aView找到0,0的位置，但bView的原点坐标已经更改成了10,10，所以bView需要向左上偏移找到0,0点的位置。</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821165537358.png" alt="image-20200821165537358"></p>
<p>如果需要改回重叠时的状态，可以更改bView的frame值，<code>bView.frame = CGRectMake(10, 10, 100, 100);</code> 。</p>
<p>如果更改aView的bounds.size的属性为   <code>aView.bounds = CGRectMake(10, 10, 100, 50);</code>  通过后台打印出aView的frame值变更成了{100, 125, 100, 50}，这是因为bounds.size属性修改时，aview会以center属性为中心进行相对收缩，上下各25，所以frame.origin.y 增加了25。</p>
<p><img src="/var/folders/sd/1syvrczd63nb9hqk_m0kp8f00000gn/T/abnerworks.Typora/image-20200821172801556.png" alt="image-20200821172801556"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/06/19/千奇百怪的奔溃（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/19/千奇百怪的奔溃（一）/" itemprop="url">千奇百怪的奔溃（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-19T16:24:53+08:00">
                2019-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>App 上线后，我们最怕的应该就是异常奔溃了。常见的奔溃类型分两种：信号可捕获奔溃、信号不可捕获奔溃，前者比较典型的代表有<code>KVO</code>问题、<code>NSNotification</code>问题、数组越界、野指针等，后者比较典型的是后台任务超时、内存打爆、主线程卡顿超阀值等。</p>
<p>那么怎样才能做到两种类型都能够加以监控？</p>
<p>信号可捕获奔溃通常我们可以通过捕捉<code>Signal</code>异常来处理，先对各种类型的信号进行注册，捕获到异常后通过 <code>backtrace_symbols</code> 方法就可以获取当前的堆栈信息。堆栈信息可以先保存在本地，下次启动时再上传到奔溃监控服务器就可以了。新建一个<code>CrashHandler</code>类，信号可捕获奔溃实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void handleSignalException(int signal) &#123;</span><br><span class="line">    NSMutableString *mstr = [[NSMutableString alloc] init];</span><br><span class="line">    [mstr appendString:@&quot;Stack:\n&quot;];</span><br><span class="line">    void* callstack[128];</span><br><span class="line">    int i, frames = backtrace(callstack, 128);</span><br><span class="line">    char** strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    for (i = 0; i &lt; frames; ++i) &#123;</span><br><span class="line">        [mstr appendFormat:@&quot;%s\n&quot;, strs[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [CrashHandler saveCrash:mstr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void registerSignalHandler(void) &#123;</span><br><span class="line">    signal(SIGHUP, handleSignalException);  //程序终端终止信号</span><br><span class="line">    signal(SIGINT, handleSignalException);  //程序键盘终止信号</span><br><span class="line">    //和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。</span><br><span class="line">    signal(SIGQUIT, handleSignalException);</span><br><span class="line">    </span><br><span class="line">    signal(SIGABRT, handleSignalException); //程序终止命令终止信号</span><br><span class="line">    signal(SIGILL, handleSignalException);  //程序非法指令信号</span><br><span class="line">    signal(SIGSEGV, handleSignalException); //程序试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.</span><br><span class="line">    signal(SIGFPE, handleSignalException);  //在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</span><br><span class="line">    //非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</span><br><span class="line">    signal(SIGBUS, handleSignalException);</span><br><span class="line">    //管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</span><br><span class="line">    signal(SIGPIPE, handleSignalException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号不可捕获奔溃我们可以通过 <code>NSSetUncaughtExceptionHandler</code> 来做异常处理，我们要做的是先在 <code>APPDelegate</code> 中通过 <code>NSSetUncaughtExceptionHandler</code> 注册抓取函数，在函数内打印异常的堆栈信息、异常原因、异常名称，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void InstallUncaughtExceptionHandler(void) &#123;</span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;HandleException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HandleException(NSException *exception) &#123;</span><br><span class="line">    //异常的堆栈信息</span><br><span class="line">    NSArray *stackArray = [exception callStackSymbols];</span><br><span class="line">    //出现异常的原因</span><br><span class="line">    NSString *reason = [exception reason];</span><br><span class="line">    //异常名称</span><br><span class="line">    NSString *name = [exception name];</span><br><span class="line">    NSString *exceptionInfo = [NSString stringWithFormat:@&quot;Exception reason %@\nException name %@\nException stack %@&quot;, name, reason, stackArray];</span><br><span class="line">    </span><br><span class="line">    [CrashHandler saveCrash:exceptionInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>saveCrash</code> 方法的具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  错误日志本地储存</span><br><span class="line"> *  TODO:错误堆栈信息可以先储存在本地，等下次启动时提交服务器</span><br><span class="line"> */</span><br><span class="line">+(void)saveCrash:(NSString *)exceptionInfo</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _libPath  = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:@&quot;Crash&quot;];</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:_libPath])&#123;</span><br><span class="line">        [[NSFileManager defaultManager] createDirectoryAtPath:_libPath withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDate *dat = [NSDate dateWithTimeIntervalSinceNow:0];</span><br><span class="line">    NSTimeInterval a = [dat timeIntervalSince1970];</span><br><span class="line">    NSString *timeString = [NSString stringWithFormat:@&quot;%f&quot;, a];</span><br><span class="line">    </span><br><span class="line">    NSString * savePath = [_libPath stringByAppendingFormat:@&quot;/error%@.log&quot;,timeString];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;__savePath %@&quot;, savePath);</span><br><span class="line">    </span><br><span class="line">    BOOL sucess = [exceptionInfo writeToFile:savePath atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;YES sucess:%d&quot;,sucess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在<code>AppDelegate</code>的<code>application: didFinishLaunchingWithOptions:</code> 中对<code>registerSignalHandler()</code> 和 <code>InstallUncaughtExceptionHandler()</code> 进行注册，就可以对两种奔溃类型进行监控，监控到的异常日志可以通过<code>saveCrash</code>方法中的 <code>savePath</code> 拿到 <code>log</code> 路径并加以分析，完美点的做法也可以在App下次启东时将错误日志上传到奔溃日志服务器。</p>
<p>详细的案例可以参考<a href="https://github.com/havendev/AnalyticsDemo" target="_blank" rel="noopener">AnalyticsDemo</a>中的<code>Demo-CrashViewController</code> 以及 <code>AppDelegate-applicationDidEnterBackground: -模拟后台奔溃</code>。</p>
<p>错误日志分析可以参考<a href="https://developer.apple.com/videos/play/wwdc2018/414/" target="_blank" rel="noopener">WWDC-2018</a>的视频，讲得很好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/06/05/无侵入的埋点方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/05/无侵入的埋点方案/" itemprop="url">无侵入的埋点方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-05T10:17:14+08:00">
                2019-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>埋点统计在产品运营过程中对用户行为分析、产品前期的业务模式探索起着很重要的作用。常用的三种埋点方式主要包括手动埋点、可视化埋点和无痕埋点。</p>
<ul>
<li>手动埋点主要是通过手写代码的方式哪里需要埋哪里，优点是数据精准、方便调试、能够自定义所需的变量值，缺点是工作量较大、埋点代码多容易产生冗余、后期难维护等；</li>
<li>可视化埋点指前端或者APP端基于DOM元素和控件所精准自动埋点的上报的方案，优点是相比较于无埋点相而言对较低，但是这个可视化元素的识别技术是客户端或者前端所要实现的，唯一 ID 生成也无需客户端去自定义规则，这套生成规则由相关产品在自动化工具的情况下生成配置表，下发到客户端，再由客户端按坑就班到相关界面去实现、数据量相对精确。缺点是可视化工具的平台的搭建，静态页面的元素识别都需要额外开发、动态效果可能会遗漏。（可参考：<a href="https://kyson.cn/index.php/archives/146/" target="_blank" rel="noopener">可视化埋点(2)：iOS端实现</a>）</li>
<li>无痕埋点指的是通过编译工具、预编译替换代码等，直接由SDK全部负责采集上报，优点是代码不会出现在业务代码中、容易管理和维护，缺点是后期的结息比较复杂、view_path不能做到100%唯一、后端或产品人员数据分析工作量大。</li>
</ul>
<p>三种埋点方案中，可视化埋点和无痕埋点，都属于无侵入的埋点方案，因为它们都不需要在业务代码中写入埋点代码。采用无侵入埋点方案，既可以做到埋点被统一维护，又可以实现和工程代码的解耦。其中无痕埋点方案能够满足大多数应用的埋点需求。</p>
<h1 id="无痕埋点方案介绍"><a href="#无痕埋点方案介绍" class="headerlink" title="无痕埋点方案介绍"></a>无痕埋点方案介绍</h1><p>最常见的三种埋点类型有页面进入次数、页面停留时间、点击事件。对于这三种常见的情况，我们都可以通过runtime的method swizzling来插入埋点代码，以实现无侵入的埋点方法，可分三步来处理：实现替换、生成唯一标识、数据上报。</p>
<p>新建一个方法替换类NSObject+Logger，加上替换的方法swizzleSelectorFromSelector : toSelector :，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (void)swizzleSelectorFromSelector:(SEL)originalSelector toSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector);</span><br><span class="line">    </span><br><span class="line">    BOOL didAddMethod =</span><br><span class="line">    class_addMethod(self,</span><br><span class="line">                    originalSelector,</span><br><span class="line">                    method_getImplementation(swizzledMethod),</span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    </span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(self,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法利用运行时method_exchangeImplementations接口将方法的实现进行了交换，原方法调用时就会被hook住，从而去执行指定的方法。</p>
<h2 id="页面进入次数、页面停留时间事件"><a href="#页面进入次数、页面停留时间事件" class="headerlink" title="页面进入次数、页面停留时间事件"></a>页面进入次数、页面停留时间事件</h2><p>页面进入次数、页面停留时间需要对UIViewController生命周期进行埋点，可以创建一个UIViewController的Category，通过NSObject+Logger将原生方法替换，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = NSClassFromString(@&quot;UIViewController&quot;);</span><br><span class="line">        [class swizzleSelectorFromSelector:@selector(viewWillAppear:) toSelector:@selector(hook_viewWillAppear:)];</span><br><span class="line">        [class swizzleSelectorFromSelector:@selector(viewWillDisappear:) toSelector:@selector(hook_viewWillDisappear:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hook_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    //先执行插入代码，再执行原 viewWillAppear 方法</span><br><span class="line">    [self insertToViewWillAppear];</span><br><span class="line">    </span><br><span class="line">    [self hook_viewWillAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hook_viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    //先执行插入代码，再执行原 viewWillDisappear 方法</span><br><span class="line">    [self insertToViewWillDisappear];</span><br><span class="line">    </span><br><span class="line">    [self hook_viewWillDisappear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据上报部分这里没有做具体介绍，可以自行对接自己的后端接口或者一些第三方平台，如友盟。</p>
<h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>常用的控件如UIButton、UITextField、UISwitch、UISegmentedControl、UISlider 等，它们的父类都是UIControl ，我们可对sendAction:to:forEvent: 进行拦截，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (void) load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        //可监听到UIButton、UITextField、UISwitch、UISegmentedControl、UISlider 、UIStepper等控件的Action事件</span><br><span class="line">        [self swizzleSelectorFromSelector:@selector(sendAction:to:forEvent:) toSelector:@selector(hook_sendAction:to:forEvent:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark--</span><br><span class="line">#pragma 按钮点击</span><br><span class="line">- (void)hook_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</span><br><span class="line">    [self insertToSendAction:action to:target forEvent:event];</span><br><span class="line">    </span><br><span class="line">    [self hook_sendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)insertToSendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</span><br><span class="line">    //日志记录</span><br><span class="line">    if ([[[event allTouches] anyObject] phase] == UITouchPhaseEnded) &#123;</span><br><span class="line">        NSString *actionString = NSStringFromSelector(action);</span><br><span class="line">        NSString *targetString = NSStringFromClass([target class]);</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;唯一标识：%@_%@_%@&quot;, targetString, self.accessibilityIdentifier, actionString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h2><p>这里的唯一标识组成规则是NSStringFromClass([target class])+self.accessibilityIdentifier，accessibilityIdentifier+NSStringFromSelector(action)，accessibilityIdentifier系统默认为nil，我们需要根据不同控件的特性为accessibilityIdentifier进行赋值，如UIButton控件的accessibilityIdentifier可以是控件的变量名，考虑到用XIB或SB布局不一定会定义变量，可取button的title值或者image的名字来定义，新建一个UIView+Logger类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIView (Logger)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;        </span><br><span class="line">        Class class = NSClassFromString(@&quot;UIView&quot;);</span><br><span class="line">        [class swizzleSelectorFromSelector:@selector(accessibilityIdentifier) toSelector:@selector(hook_accessibilityIdentifier)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Method Swizzling</span><br><span class="line">- (NSString *)hook_accessibilityIdentifier &#123;</span><br><span class="line">    NSString *labelStr = [self.superview findNameWithInstance:self];</span><br><span class="line">    </span><br><span class="line">    if (labelStr &amp;&amp; ![labelStr isEqualToString:@&quot;&quot;]) &#123;</span><br><span class="line">        //SB或XIB布局的，因获取不到image的name，所以至少要拉个变量名</span><br><span class="line">        labelStr = [NSString stringWithFormat:@&quot;%@&quot;,labelStr];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([self isKindOfClass:[UIButton class]]) &#123;</span><br><span class="line">            //UIButton 使用 button 的 text 和 image</span><br><span class="line">            labelStr = [NSString stringWithFormat:@&quot;%@%@&quot;,((UIButton *)self).titleLabel.text?:@&quot;&quot;,((UIButton *)self).imageView.image.accessibilityIdentifier?:@&quot;&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self setAccessibilityIdentifier:labelStr];</span><br><span class="line">    return labelStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>findNameWithInstance:的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)findNameWithInstance:(UIView *)instance</span><br><span class="line">&#123;</span><br><span class="line">    id nextResponder = [self nextResponder];</span><br><span class="line">    NSString *name = [RuntimeHelper nameWithClass:self instance:instance];</span><br><span class="line">    if (!name) &#123;</span><br><span class="line">        return [nextResponder findNameWithInstance:instance];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ([name hasPrefix:@&quot;_&quot;]) &#123;  //去掉变量名的下划线前缀</span><br><span class="line">        name = [name substringFromIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又延伸出了一个问题，UIImage 并没有提供获取资源名字的方法。解决问题的方式是通过替换 UIImage 的 imageNamed: 方法对 UIImage的accessibilityIdentifier 进行赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIImage (Logger)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;        </span><br><span class="line">        Class imageClass = NSClassFromString(@&quot;UIImage&quot;);</span><br><span class="line">        [object_getClass(imageClass) swizzleSelectorFromSelector:@selector(imageNamed:) toSelector:@selector(hook_imageNamed:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UIImage *)hook_imageNamed:(NSString *)imageName &#123;</span><br><span class="line">    UIImage *image = [UIImage hook_imageNamed:imageName];</span><br><span class="line">    image.accessibilityIdentifier = imageName;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Delegate事件"><a href="#Delegate事件" class="headerlink" title="Delegate事件"></a>Delegate事件</h2><p>Delegate 事件的 swizzling 需要分成两步，第一步先替换掉 setDelegate:  ，其次是对 Delegate 事件的替换，举个 UIScrollView 的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//我们要保证在每个控制器里都执行一次，所以替换的方法都会加上class name的前缀，以示区别</span><br><span class="line">#define GET_CLASS_CUSTOM_SEL(sel,class)  NSSelectorFromString([NSString stringWithFormat:@&quot;%@_%@&quot;,NSStringFromClass(class),NSStringFromSelector(sel)])</span><br><span class="line"></span><br><span class="line">@implementation UIScrollView (Logger)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [[self class] swizzleSelectorFromSelector:@selector(setDelegate:) toSelector:@selector(hook_setDelegate:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hook_setDelegate:(id&lt;UIScrollViewDelegate&gt;)delegate &#123;</span><br><span class="line">    // 由于setDelegate方法可能被多次调用，所以要判断是否已经swizzling了，防止重复执行。</span><br><span class="line">    if (![[self class] delegate:delegate isContain:@selector(scrollViewWillBeginDragging:)]) &#123;</span><br><span class="line">        [self hook_scrollViewWillBeginDragging:delegate];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([NSStringFromClass([self class]) isEqualToString:@&quot;UITableView&quot;])&#123;</span><br><span class="line">        if (![[self class] delegate:delegate isContain:@selector(tableView:didSelectRowAtIndexPath:)]) &#123;</span><br><span class="line">            [(UITableView *)self hook_tableViewDidSelectRowAtIndexPathInClass:delegate];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self hook_setDelegate:delegate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma --</span><br><span class="line">#pragma UIScrollViewDelegate</span><br><span class="line">- (void)hook_scrollViewWillBeginDragging:(id&lt;UIScrollViewDelegate&gt;)delegate &#123;</span><br><span class="line">    [[self class] swizzleDelegate:delegate originSelector:@selector(scrollViewWillBeginDragging:) swizzleSelector:@selector(insertToScrollViewWillBeginDragging:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)insertToScrollViewWillBeginDragging:(UIScrollView *)scrollView &#123;</span><br><span class="line">    SEL sel = GET_CLASS_CUSTOM_SEL(@selector(scrollViewWillBeginDragging:),[self class]);</span><br><span class="line">    if ([self respondsToSelector:sel]) &#123;</span><br><span class="line">        IMP imp = [self methodForSelector:sel];</span><br><span class="line">        void (*func)(id, SEL,id) = (void *)imp;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;标识：%@_%@_%@&quot;, NSStringFromClass([self class]), [RuntimeHelper nameWithClass:self instance:scrollView], NSStringFromSelector(@selector(scrollViewWillBeginDragging:)));</span><br><span class="line">        </span><br><span class="line">        func(self, sel, scrollView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSObject+Logger类新增 delegate: isContain: 和 swizzleDelegate: originSelector: swizzleSelector: 两个方法，完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#define GET_CLASS_CUSTOM_SEL(sel,class)  NSSelectorFromString([NSString stringWithFormat:@&quot;%@_%@&quot;,NSStringFromClass(class),NSStringFromSelector(sel)])</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Logger)</span><br><span class="line">+ (void)swizzleSelectorFromSelector:(SEL)originalSelector toSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector);</span><br><span class="line"></span><br><span class="line">//    NSLog(@&quot;__delegateObject %@&quot;, [self class]);</span><br><span class="line"></span><br><span class="line">    BOOL didAddMethod =</span><br><span class="line">    class_addMethod(self,</span><br><span class="line">                    originalSelector,</span><br><span class="line">                    method_getImplementation(swizzledMethod),</span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line"></span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(self,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)delegate:(id)delegateObject isContain:(SEL)selector &#123;</span><br><span class="line">    return [self isContainSel:GET_CLASS_CUSTOM_SEL(selector, [delegateObject class]) inClass:[delegateObject class]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)swizzleDelegate:(id)delegateObject originSelector:(SEL)originSelector swizzleSelector:(SEL)swizzleSelector &#123;</span><br><span class="line">    SEL newSelector = GET_CLASS_CUSTOM_SEL(originSelector, [delegateObject class]);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod([delegateObject class], swizzleSelector);</span><br><span class="line">    </span><br><span class="line">    //增加swizzle delegate method</span><br><span class="line">    class_addMethod([delegateObject class],</span><br><span class="line">                    newSelector,</span><br><span class="line">                    method_getImplementation(class_getInstanceMethod([self class], swizzleSelector)),</span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    </span><br><span class="line">    Method swizzleDelegateMethod = class_getInstanceMethod([delegateObject class], newSelector);</span><br><span class="line">    Method originDelegateMethod = class_getInstanceMethod([delegateObject class], originSelector);</span><br><span class="line">    </span><br><span class="line">    // 将swizzle delegate method 和 origin delegate method 交换</span><br><span class="line">    method_exchangeImplementations(swizzleDelegateMethod, originDelegateMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isContainSel:(SEL)sel inClass:(Class)class &#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    </span><br><span class="line">    Method *methodList = class_copyMethodList(class,&amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        NSString *tempMethodString = [NSString stringWithUTF8String:sel_getName(method_getName(method))];</span><br><span class="line">        if ([tempMethodString isEqualToString:NSStringFromSelector(sel)]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据上报的方式这里没有做过多的介绍，可通过集成第三方统计平台或自搭服务进行对接，<a href="https://github.com/havendev/AnalyticsDemo" target="_blank" rel="noopener">完整的DEMO参考这里</a>。</p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://kyson.cn/index.php/archives/145/" target="_blank" rel="noopener">可视化埋点(1)：思路</a></p>
<p><a href="https://xietao3.com/2017/05/dataStatistics/" target="_blank" rel="noopener">iOS无埋点数据统计实践</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/05/09/Mac共享ShadowSocks代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/Mac共享ShadowSocks代理/" itemprop="url">Mac共享ShadowSocks代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-09T15:24:04+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为开发人员，我们经常遇到需要查阅国外资料的场景，大多数情况下只要满足PC端的需求就可以了，不过作为个移动开发人员，手机端也是个刚需。Mac端用<strong><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">ShadowsocksX-NG</a></strong>可以解决，Mac有个天然的优势是可以通过【设置-共享-互联共享-Wi-Fi】把本机网络作为Wifi热点进行共享。但开启了Shadowsocks后，手机端却不能正常访问国外内容，这就很尴尬了。</p>
<p>查阅了资料，原因是OS X的内核没有提供设置代理服务器进行局域网共享的功能 ，下面说下解决方案。</p>
<p>整体思路是通过<a href="http://www.privoxy.org/" target="_blank" rel="noopener">Privoxy</a> 代理本机的 SOCKS5连接来实现 ShadowSocks 的共享：</p>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>直接通过<a href="http://www.privoxy.org/" target="_blank" rel="noopener">http://www.privoxy.org/</a>下载，或使用Homebrew安装：</p>
<p><code>brew install privoxy</code></p>
<h2 id="二、修改配置"><a href="#二、修改配置" class="headerlink" title="二、修改配置"></a>二、修改配置</h2><ul>
<li><p>查看<strong><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">ShadowsocksX-NG</a></strong>的SOCKS5端口号：ShadowsocksX-NG-偏好设置-高级-本地Socks5监听端口，记录</p>
</li>
<li><p>前往/usr/local/etc/privoxy/config，找到forward-socks5t去掉注释，将端口号改为刚记下的Socks5监听端口 <code>forward-socks5t   /               127.0.0.1:1086 .</code></p>
</li>
<li><p>搜索listen-address，去掉注释，把127.0.0.1改为0.0.0.0（否则只能作用于本机），端口号改为一个未占用的端口</p>
<p><code>listen-address  0.0.0.0:6666</code></p>
</li>
</ul>
<h2 id="三、运行"><a href="#三、运行" class="headerlink" title="三、运行"></a>三、运行</h2><p>打开终端运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/sbin/</span><br><span class="line">./privoxy --no-daemon /usr/local/etc/privoxy/config</span><br></pre></td></tr></table></figure>
<h2 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h2><p>将iPhone连接Mac共享的Wifi，点击查看Wifi详情，找到HTTP代理，选择手动填入<strong>Mac本机IP</strong>+<strong>刚设置的6666端口号</strong>，储存即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>将Mac上的SS代理共享给其他设备</p>
<p><a href="http://1992s.com/share-shadowsocks-over-lan-on-mac-os-x.html" target="_blank" rel="noopener">http://1992s.com/share-shadowsocks-over-lan-on-mac-os-x.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/05/05/（二）iOS实现简单的HLS拉流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/（二）iOS实现简单的HLS拉流/" itemprop="url">（二）iOS实现简单的HLS拉流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-05T17:27:10+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、配置RTMP推流环境"><a href="#一、配置RTMP推流环境" class="headerlink" title="一、配置RTMP推流环境"></a>一、配置RTMP推流环境</h2><p>可以参考上文《MAC环境下RTMP推流环境搭建》搭建好RTMP推流环境。 </p>
<h2 id="二、修改nginx配置"><a href="#二、修改nginx配置" class="headerlink" title="二、修改nginx配置"></a>二、修改nginx配置</h2><p>因为iOS不直接支持RTMP，但是可以通过AVPlayer/AVPlayerViewController快速的实现HLS流媒体播放，因此需要调整下nginx配置，让nginx支持HLS. </p>
<p>主要改动以下2个点： </p>
<p>在http内的location /{}下面添加： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /hls &#123; </span><br><span class="line"></span><br><span class="line">    #Server HLS Config </span><br><span class="line"></span><br><span class="line">    types &#123; </span><br><span class="line"></span><br><span class="line">        application/vnd.apple.mpegurl m3u8; </span><br><span class="line"></span><br><span class="line">        video/mp2t ts; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    root /usr/local/var/www; </span><br><span class="line"></span><br><span class="line">    add_header Cache-Control no-cache; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在rtmp里添加 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">application hls &#123; </span><br><span class="line"></span><br><span class="line">    live on; </span><br><span class="line"></span><br><span class="line">    hls on; </span><br><span class="line"></span><br><span class="line">    hls_path /usr/local/var/www/hls; </span><br><span class="line"></span><br><span class="line">    hls_fragment 1s; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完成后，执行nginx -s reload重启nginx。 </p>
<h2 id="三、HLS推流"><a href="#三、HLS推流" class="headerlink" title="三、HLS推流"></a>三、HLS推流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i xxx.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://localhost:1935/hls/demo</span><br></pre></td></tr></table></figure>
<p>可在浏览器直接访问地址<a href="http://localhost:8080/hls/demo.m3u8" target="_blank" rel="noopener">http://localhost:8080/hls/demo.m3u8</a>验证是否能正常播放。 </p>
<h2 id="四、使用AVPlayer-AVPlayerViewController播放HLS推流"><a href="#四、使用AVPlayer-AVPlayerViewController播放HLS推流" class="headerlink" title="四、使用AVPlayer/AVPlayerViewController播放HLS推流"></a>四、使用AVPlayer/AVPlayerViewController播放HLS推流</h2><p>这里比较简单，核心代码如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">\- (void)initializePlayer &#123; </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    NSURL *playFilePathURL = [NSURL URLWithString:@&quot;http://192.168.10.79:8080/hls/demo.m3u8&quot;]; </span><br><span class="line"></span><br><span class="line">    AVPlayerItem *playerItem = [AVPlayerItem playerItemWithURL:playFilePathURL]; </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    self.player = [[AVPlayer alloc] initWithPlayerItem:playerItem]; </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    self.playerLayer = [AVPlayerLayer playerLayerWithPlayer:self.player]; </span><br><span class="line"></span><br><span class="line">    self.playerLayer.frame = self.view.bounds; </span><br><span class="line"></span><br><span class="line">    self.playerLayer.videoGravity = AVLayerVideoGravityResizeAspect; </span><br><span class="line"></span><br><span class="line">    [self.view.layer addSublayer:self.playerLayer]; </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    [self.player.currentItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil]; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偷懒的可以直接：<a href="https://github.com/havendev/SimpleHLSPlayer" target="_blank" rel="noopener">https://github.com/havendev/SimpleHLSPlayer</a></p>
<h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><p>想了解在iOS端实现RTMP拉流的，可以研究下<a href="https://github.com/bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/05/05/一、MAC环境下RTMP推流环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海文">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Haven's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/一、MAC环境下RTMP推流环境搭建/" itemprop="url">（一）MAC环境下RTMP推流环境搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-05T15:15:39+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文主要介绍MAC环境下如何配置简单的RTMP推流环境</p>
<h2 id="一、Nginx环境配置"><a href="#一、Nginx环境配置" class="headerlink" title="一、Nginx环境配置"></a>一、Nginx环境配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew tap denji/nginx    //先clone nginx项目到本地 </span><br><span class="line"></span><br><span class="line">brew install nginx-full --with-rtmp-module    //安装rtmp版本的nginx </span><br><span class="line"></span><br><span class="line">sudo nginx            //启动nginx </span><br><span class="line"></span><br><span class="line">TODO:基于原本的Nginx环境添加rtmp模块</span><br></pre></td></tr></table></figure>
<h2 id="二、配置RMTP环境"><a href="#二、配置RMTP环境" class="headerlink" title="二、配置RMTP环境"></a>二、配置RMTP环境</h2><p>通过Finder前往/usr/local/etc/nginx/nginx.conf，在最下方添加 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\# 在http节点后面加上rtmp配置：</span><br><span class="line"></span><br><span class="line">rtmp &#123;</span><br><span class="line"></span><br><span class="line">   server &#123;</span><br><span class="line"></span><br><span class="line">​       listen 1935;</span><br><span class="line"></span><br><span class="line">​       application rtmplive &#123;</span><br><span class="line"></span><br><span class="line">​           live on;</span><br><span class="line"></span><br><span class="line">​           record off;</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后重启nginx，执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h2 id="三、配置FFMpeg环境"><a href="#三、配置FFMpeg环境" class="headerlink" title="三、配置FFMpeg环境"></a>三、配置FFMpeg环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>
<h2 id="四、安装VLC播放器"><a href="#四、安装VLC播放器" class="headerlink" title="四、安装VLC播放器"></a>四、安装VLC播放器</h2><p>官网直接下一个：<a href="https://www.videolan.org/" target="_blank" rel="noopener">https://www.videolan.org</a> </p>
<h2 id="五、推流"><a href="#五、推流" class="headerlink" title="五、推流"></a>五、推流</h2><p>随便找个地方放个视频文件，如桌面上方个testvideo.mp4 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i xxx.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/rtmplive/room</span><br></pre></td></tr></table></figure>
<p>推流成功！ </p>
<h2 id="六、MAC播放直播"><a href="#六、MAC播放直播" class="headerlink" title="六、MAC播放直播"></a>六、MAC播放直播</h2><p>打开安装完成的VLC应用，复制<a href="rtmp://localhost:1935/rtmplive/room" target="_blank" rel="noopener">rtmp://localhost:1935/rtmplive/room</a>地址，选择File ——&gt; Open Network粘贴地址进输入框点open，等待一会就可以看到播放了。 </p>
<h2 id="七、iPhone播放直播"><a href="#七、iPhone播放直播" class="headerlink" title="七、iPhone播放直播"></a>七、iPhone播放直播</h2><p>上文提到的VLC也提供了iOS端，去AppStore下载一个VLC客户端，打开后点击左上角的图标，选择网络串流，输入刚刚的推流地址，这里需要确保iPhone的网络跟MAC端是同一个局域网内，把localhost换成MAC本机的ip地址。 </p>
<p><strong>参考文献：</strong></p>
<p><a href="http://auan.cn/server/1716.html" target="_blank" rel="noopener">如何在已经安装好的Nginx上增加新模块nginx-rtmp-module</a></p>
<p><a href="https://blog.csdn.net/lg767201403/article/details/83009938" target="_blank" rel="noopener">Mac搭建nginx+rtmp服务器，通过ffmpeg实现视频推流</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">海文</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">海文</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
